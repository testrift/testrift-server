/**
 * MessagePack decoder for browser (minimal implementation)
 * Supports decoding MessagePack binary data to JavaScript objects
 */
(function(global) {
    'use strict';

    function Decoder(buffer) {
        this.buffer = new Uint8Array(buffer);
        this.offset = 0;
    }

    Decoder.prototype.read = function(n) {
        var result = this.buffer.subarray(this.offset, this.offset + n);
        this.offset += n;
        return result;
    };

    Decoder.prototype.readU8 = function() {
        return this.buffer[this.offset++];
    };

    Decoder.prototype.readU16 = function() {
        var a = this.buffer[this.offset++];
        var b = this.buffer[this.offset++];
        return (a << 8) | b;
    };

    Decoder.prototype.readU32 = function() {
        var a = this.buffer[this.offset++];
        var b = this.buffer[this.offset++];
        var c = this.buffer[this.offset++];
        var d = this.buffer[this.offset++];
        return (a * 0x1000000) + ((b << 16) | (c << 8) | d);
    };

    Decoder.prototype.readI8 = function() {
        var val = this.buffer[this.offset++];
        return val < 0x80 ? val : val - 0x100;
    };

    Decoder.prototype.readI16 = function() {
        var val = this.readU16();
        return val < 0x8000 ? val : val - 0x10000;
    };

    Decoder.prototype.readI32 = function() {
        var a = this.buffer[this.offset++];
        var b = this.buffer[this.offset++];
        var c = this.buffer[this.offset++];
        var d = this.buffer[this.offset++];
        return (a << 24) | (b << 16) | (c << 8) | d;
    };

    Decoder.prototype.readF32 = function() {
        var bytes = this.read(4);
        var view = new DataView(bytes.buffer, bytes.byteOffset, 4);
        return view.getFloat32(0, false);
    };

    Decoder.prototype.readF64 = function() {
        var bytes = this.read(8);
        var view = new DataView(bytes.buffer, bytes.byteOffset, 8);
        return view.getFloat64(0, false);
    };

    Decoder.prototype.readString = function(len) {
        var bytes = this.read(len);
        var result = '';
        for (var i = 0; i < len; i++) {
            var byte = bytes[i];
            if (byte < 0x80) {
                result += String.fromCharCode(byte);
            } else if ((byte & 0xe0) === 0xc0) {
                var byte2 = bytes[++i];
                result += String.fromCharCode(((byte & 0x1f) << 6) | (byte2 & 0x3f));
            } else if ((byte & 0xf0) === 0xe0) {
                var byte2 = bytes[++i];
                var byte3 = bytes[++i];
                result += String.fromCharCode(((byte & 0x0f) << 12) | ((byte2 & 0x3f) << 6) | (byte3 & 0x3f));
            } else if ((byte & 0xf8) === 0xf0) {
                var byte2 = bytes[++i];
                var byte3 = bytes[++i];
                var byte4 = bytes[++i];
                var codePoint = ((byte & 0x07) << 18) | ((byte2 & 0x3f) << 12) | ((byte3 & 0x3f) << 6) | (byte4 & 0x3f);
                codePoint -= 0x10000;
                result += String.fromCharCode((codePoint >> 10) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
            }
        }
        return result;
    };

    Decoder.prototype.readBin = function(len) {
        return this.read(len);
    };

    Decoder.prototype.readArray = function(len) {
        var result = new Array(len);
        for (var i = 0; i < len; i++) {
            result[i] = this.decode();
        }
        return result;
    };

    Decoder.prototype.readMap = function(len) {
        var result = {};
        for (var i = 0; i < len; i++) {
            var key = this.decode();
            var value = this.decode();
            result[key] = value;
        }
        return result;
    };

    Decoder.prototype.decode = function() {
        var type = this.readU8();

        // Positive fixint (0x00 - 0x7f)
        if (type < 0x80) {
            return type;
        }
        // Fixmap (0x80 - 0x8f)
        if ((type & 0xf0) === 0x80) {
            return this.readMap(type & 0x0f);
        }
        // Fixarray (0x90 - 0x9f)
        if ((type & 0xf0) === 0x90) {
            return this.readArray(type & 0x0f);
        }
        // Fixstr (0xa0 - 0xbf)
        if ((type & 0xe0) === 0xa0) {
            return this.readString(type & 0x1f);
        }
        // nil
        if (type === 0xc0) {
            return null;
        }
        // false
        if (type === 0xc2) {
            return false;
        }
        // true
        if (type === 0xc3) {
            return true;
        }
        // bin 8
        if (type === 0xc4) {
            return this.readBin(this.readU8());
        }
        // bin 16
        if (type === 0xc5) {
            return this.readBin(this.readU16());
        }
        // bin 32
        if (type === 0xc6) {
            return this.readBin(this.readU32());
        }
        // float 32
        if (type === 0xca) {
            return this.readF32();
        }
        // float 64
        if (type === 0xcb) {
            return this.readF64();
        }
        // uint 8
        if (type === 0xcc) {
            return this.readU8();
        }
        // uint 16
        if (type === 0xcd) {
            return this.readU16();
        }
        // uint 32
        if (type === 0xce) {
            return this.readU32();
        }
        // uint 64
        if (type === 0xcf) {
            var hi = this.readU32();
            var lo = this.readU32();
            return hi * 0x100000000 + lo;
        }
        // int 8
        if (type === 0xd0) {
            return this.readI8();
        }
        // int 16
        if (type === 0xd1) {
            return this.readI16();
        }
        // int 32
        if (type === 0xd2) {
            return this.readI32();
        }
        // int 64
        if (type === 0xd3) {
            var hi = this.readI32();
            var lo = this.readU32();
            return hi * 0x100000000 + lo;
        }
        // str 8
        if (type === 0xd9) {
            return this.readString(this.readU8());
        }
        // str 16
        if (type === 0xda) {
            return this.readString(this.readU16());
        }
        // str 32
        if (type === 0xdb) {
            return this.readString(this.readU32());
        }
        // array 16
        if (type === 0xdc) {
            return this.readArray(this.readU16());
        }
        // array 32
        if (type === 0xdd) {
            return this.readArray(this.readU32());
        }
        // map 16
        if (type === 0xde) {
            return this.readMap(this.readU16());
        }
        // map 32
        if (type === 0xdf) {
            return this.readMap(this.readU32());
        }
        // Negative fixint (0xe0 - 0xff)
        if (type >= 0xe0) {
            return type - 0x100;
        }

        throw new Error('Unknown MessagePack type: 0x' + type.toString(16));
    };

    function decode(buffer) {
        var decoder = new Decoder(buffer);
        return decoder.decode();
    }

    // Export
    var msgpack = {
        decode: decode,
        Decoder: Decoder
    };

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = msgpack;
    } else {
        global.msgpack = msgpack;
    }
})(typeof window !== 'undefined' ? window : this);
