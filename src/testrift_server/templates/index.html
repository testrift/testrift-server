<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Test Runs Index</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Compensate for Bootstrap 3 to 5 migration: restore original font sizes and link colors */
        :root {
            font-size: 14px; /* Bootstrap 3 used 14px base, Bootstrap 5 uses 16px */
        }

        a {
            color: #337ab7; /* Bootstrap 3 link color */
        }

        a:hover {
            color: #23527c; /* Bootstrap 3 link hover color */
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.428571429; /* Bootstrap 3 line-height */
        }

        .group-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(102, 126, 234, 0.12);
            color: #4c6ef5;
            font-size: 0.85em;
            font-weight: 600;
            margin-top: 8px;
        }

        .group-pill .group-link {
            color: inherit;
            text-decoration: none;
        }

        .group-pill .group-link:hover {
            text-decoration: underline;
        }

        .main-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin: 20px auto;
            padding: 0;
            overflow: hidden;
        }

        .header-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header-section h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header-section .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-top: 10px;
        }

        .content-section {
            padding: 30px;
        }

        .runs-table {
            width: 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            border-collapse: collapse;
            table-layout: fixed !important;
        }

        .table-header {
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .table-header th {
            padding: 12px 10px;
            text-align: left;
            font-weight: 600;
            color: #495057;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .table-header th:first-child {
            width: 120px !important;
            max-width: 120px !important;
            min-width: 120px !important;
            text-align: left;
        }

        .table-header th:nth-child(1),
        .run-item td:nth-child(1),
        thead th:first-child,
        tbody td:first-child {
            width: 120px !important;
            max-width: 120px !important;
            min-width: 120px !important;
        }

        .table-header th:nth-child(2),
        .run-item td:nth-child(2) {
            width: 300px !important;
            max-width: 300px !important;
            min-width: 300px !important;
        }

        .table-header th:nth-child(3),
        .run-item td:nth-child(3) {
            width: auto;
            min-width: 250px;
        }

        .table-header th:nth-child(4),
        .run-item td:nth-child(4) {
            width: 133px !important;
            max-width: 133px !important;
            min-width: 133px !important;
        }


        .run-item {
            background: white;
            transition: all 0.2s ease;
        }

        .run-item td {
            padding: 12px 10px;
            vertical-align: top;
            border-bottom: 1px solid #e9ecef;
        }

        .run-item:last-child td {
            border-bottom: none;
        }

        .run-item.new-run {
            animation: slideInFromTop 0.6s ease-out;
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes statusUpdate {
            0% {
                border-left-color: #667eea;
            }
            50% {
                border-left-color: #28a745;
                box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            }
            100% {
                border-left-color: #667eea;
            }
        }

        .run-item.status-updated {
            animation: statusUpdate 0.8s ease-in-out;
        }

        .run-item:hover {
            background: #f8f9fa;
        }

        .run-item.new-run {
            animation: slideInFromTop 0.6s ease-out;
        }

        .group-banner {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .group-banner-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .group-title-label {
            font-size: 0.85em;
            letter-spacing: 0.4px;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 6px;
        }

        .group-banner h2 {
            margin: 0;
            color: #495057;
            font-size: 1.5em;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            display: inline-block;
        }

        .group-banner-links {
            display: inline-flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .group-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .group-info-item {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            text-align: left;
        }

        .group-info-item strong {
            display: block;
            font-size: 0.85em;
            text-transform: uppercase;
            color: #667eea;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }

        .group-info-item span {
            color: #212529;
            font-weight: 600;
        }

        .group-link {
            font-weight: 600;
            color: #ffe9a7;
        }

        .status-column {
            text-align: center;
            vertical-align: top;
            width: 120px !important;
            max-width: 120px !important;
            min-width: 120px !important;
            overflow: hidden;
            word-wrap: break-word;
        }

        .status-column > * {
            display: block !important;
            margin: 0 auto 8px auto;
        }

        .status-column > *:last-child {
            margin-bottom: 0;
        }

        .status-column .status-badge {
            display: inline-block !important;
            margin: 0 auto 8px auto;
            max-width: 100%;
            box-sizing: border-box;
        }

        .status-column .result-badges-container {
            display: flex !important;
            margin: 0 auto 0 auto;
            max-width: 100%;
            box-sizing: border-box;
            justify-content: center;
        }

        .title-column {
            vertical-align: top;
        }

        .title-column > * {
            margin-bottom: 4px;
        }

        .title-column > *:last-child {
            margin-bottom: 0;
        }

        .run-meta-section {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 1.0em;
            color: #6c757d;
            max-width: 300px;
            margin-top: 4px;
        }

        .metadata-column {
            font-size: 0.9em;
            color: #6c757d;
            line-height: 1.4;
            vertical-align: top;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .metadata-column .meta-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-right: 12px;
            margin-bottom: 4px;
            flex-shrink: 0;
        }

        .actions-column {
            text-align: right;
            vertical-align: top;
        }

        .actions-column > * {
            margin-bottom: 8px;
        }

        .actions-column > *:last-child {
            margin-bottom: 0;
        }

        .actions-column .download-btn {
            width: auto;
            min-width: auto;
        }

        .run-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #495057;
            margin: 0;
        }

        .run-link {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .run-link:hover {
            color: #764ba2;
            text-decoration: none;
        }

        .status-badge {
            display: inline-block;
            padding: 6px 10px;
            border-radius: 16px;
            font-weight: 600;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100px;
            text-align: center;
            box-sizing: border-box;
        }

        .result-badges-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
            width: 100px;
            max-width: 100px;
        }

        .result-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            min-width: 24px;
            text-align: center;
        }

        .result-passed {
            background-color: #d4edda;
            color: #155724;
        }

        .result-skipped {
            background-color: #fff3cd;
            color: #856404;
        }

        .result-failed {
            background-color: #f8d7da;
            color: #721c24;
        }

        .result-aborted {
            background-color: #e2e3e5;
            color: #6c757d;
        }

        .result-error {
            background-color: #e2e3e5;
            color: #6c757d;
        }

        .status-running {
            background: #ffc107;
            color: #000;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.2);
            display: inline-flex;
            align-items: center;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-top: 2px solid #000;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 0px;
            display: inline-block;
            vertical-align: middle;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .status-finished {
            background: #28a745;
            color: white;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.2);
        }
        .status-passed {
            background: #28a745;
            color: white;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.2);
        }

        .status-skipped {
            background: #ffc107;
            color: #000;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.2);
        }

        .status-failed {
            background: #dc3545;
            color: white;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.2);
        }

        .status-aborted {
            background: #6c757d;
            color: white;
            box-shadow: 0 2px 8px rgba(108, 117, 125, 0.2);
        }

        .status-error {
            background: #6c757d;
            color: white;
            box-shadow: 0 2px 8px rgba(108, 117, 125, 0.2);
        }

        .status-finished-passed {
            background: #28a745;
            color: white;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.2);
        }

        .status-finished-failed {
            background: #dc3545;
            color: white;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.2);
        }

        .meta-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .meta-label {
            font-weight: 600;
            color: #495057;
        }

        .meta-value {
            color: #6c757d;
        }

        .result-badges-container {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .download-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 16px;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.8em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
            display: inline-block;
            white-space: nowrap;
            min-width: auto;
            width: auto;
            height: auto;
            line-height: 1.4;
        }

        .download-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            color: white;
            text-decoration: none;
        }

        .download-btn.disabled {
            background: #6c757d;
            color: #adb5bd;
            cursor: not-allowed;
            box-shadow: none;
        }

        .download-btn.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .days-left {
            color: #6c757d;
            font-size: 0.9em;
            font-weight: 500;
            margin-left: 10px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state i {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            color: #495057;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .main-container {
                margin: 10px;
                border-radius: 10px;
            }

            .header-section {
                padding: 20px;
            }

            .header-section h1 {
                font-size: 2em;
            }

            .content-section {
                padding: 20px;
            }

            .run-item {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .status-column {
                order: 1;
            }

            .title-column {
                order: 2;
            }

            .metadata-column {
                order: 3;
            }

            .actions-column {
                order: 4;
                align-items: flex-start;
            }

            .run-meta-section {
                flex-wrap: wrap;
                gap: 8px;
            }

            .result-badges-container {
                flex-wrap: wrap;
            }
        }
    </style>
    <link href="/static/classifications.css" rel="stylesheet">
    <script src="/static/classifications.js"></script>
</head>
<body>
    <div class="main-container">
        <div class="header-section">
            {% if group_context %}
            <h1>{{ group_context.name or ('Group ' ~ group_context.hash) }} Test Runs</h1>
            <div class="subtitle">Monitor and manage your test executions</div>
            {% else %}
            <h1>Test Runs</h1>
            <div class="subtitle">Monitor and manage your test executions</div>
            {% endif %}
        </div>

        <div class="content-section">
            {% if group_context %}
            <div class="group-banner">
                <div class="group-banner-header">
                    <div>
                        <div class="group-title-label">Group</div>
                        <h2>{{ group_context.name or ('Group ' ~ group_context.hash) }}</h2>
                    </div>
                        <div class="group-banner-links">
                            <a href="/analyzer?group={{ group_context.hash }}" class="btn btn-outline-primary btn-sm">
                                <i class="fas fa-chart-line"></i> Analyzer
                            </a>
                            <a href="/matrix?group={{ group_context.hash }}" class="btn btn-outline-primary btn-sm">
                                <i class="fas fa-table"></i> Matrix
                            </a>
                            <a href="/failures?group={{ group_context.hash }}" class="btn btn-outline-primary btn-sm">
                                <i class="fas fa-bug"></i> Failures
                            </a>
                        </div>
                </div>
                <div class="group-info-grid">
                    {% set group_meta = group_context.metadata or {} %}
                    {% if group_meta %}
                        {% for name, metadata in group_meta.items() %}
                        <div class="group-info-item">
                            <strong>{{ name }}</strong>
                            <span>
                                {% if metadata.url %}
                                    <a href="{{ metadata.url }}" target="_blank">{{ metadata.value }}</a>
                                {% else %}
                                    {{ metadata.value }}
                                {% endif %}
                            </span>
                        </div>
                        {% endfor %}
                    {% else %}
                        <div class="group-info-item">
                            <span>No metadata defined for this group.</span>
                        </div>
                    {% endif %}
                </div>
            </div>
            {% endif %}
            <table class="runs-table">
                <thead class="table-header">
                    <tr>
                        <th>Status</th>
                        <th>Run</th>
                        <th>Metadata</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="runs-list">
{% for run in runs_index %}
                <tr class="run-item" data-runid="{{ run.run_id }}">
                    <td class="status-column">
                                {% if run.status.lower() == 'running' %}
                                <span class="status-badge status-running"{% if run.group and run.group.hash %} data-group-hash="{{ run.group.hash }}" data-run-id="{{ run.run_id }}"{% endif %}>RUNNING <span class="spinner"></span></span>
                                {% elif run.status.lower() == 'aborted' %}
                                <span class="status-badge status-aborted"{% if run.group and run.group.hash %} data-group-hash="{{ run.group.hash }}" data-run-id="{{ run.run_id }}"{% endif %}>ABORTED</span>
                                {% else %}
                                {% if run.skipped_count > 0 and run.passed_count == 0 and run.failed_count == 0 and (run.error_count is not defined or run.error_count == 0) %}
                                <span class="status-badge status-skipped"{% if run.group and run.group.hash %} data-group-hash="{{ run.group.hash }}" data-run-id="{{ run.run_id }}"{% endif %}>SKIPPED</span>
                                {% elif run.error_count is defined and run.error_count > 0 %}
                                <span class="status-badge status-error"{% if run.group and run.group.hash %} data-group-hash="{{ run.group.hash }}" data-run-id="{{ run.run_id }}"{% endif %}>ERROR</span>
                                {% elif run.failed_count > 0 %}
                                <span class="status-badge status-finished-failed"{% if run.group and run.group.hash %} data-group-hash="{{ run.group.hash }}" data-run-id="{{ run.run_id }}"{% endif %}>FAILED</span>
                                {% else %}
                                <span class="status-badge status-finished-passed"{% if run.group and run.group.hash %} data-group-hash="{{ run.group.hash }}" data-run-id="{{ run.run_id }}"{% endif %}>PASSED</span>
                                {% endif %}
                                {% endif %}

                        <div class="result-badges-container">
                            {% if run.passed_count > 0 %}
                            <span class="result-badge result-passed" title="Passed">{{ run.passed_count }}</span>
                            {% endif %}
                            {% if run.skipped_count > 0 %}
                            <span class="result-badge result-skipped" title="Skipped">{{ run.skipped_count }}</span>
                            {% endif %}
                            {% if run.failed_count > 0 %}
                            <span class="result-badge result-failed" title="Failed">{{ run.failed_count }}</span>
                            {% endif %}
                            {% if run.error_count is defined and run.error_count > 0 %}
                            <span class="result-badge result-error" title="Error">{{ run.error_count }}</span>
                            {% endif %}
                            </div>
                    </td>

                    <td class="title-column">
                        <h3 class="run-title">
                            <a href="/testRun/{{ run.run_id }}/index.html" class="run-link">{{ run.run_name }}</a>
                        </h3>
                        {% if run.group and (run.group.name or run.group.hash) and not group_context %}
                        <div class="group-pill">
                            <span>Group:</span>
                            {% if run.group.hash %}
                                <a href="/groups/{{ run.group.hash }}" class="group-link">{{ run.group.name or ('Group ' ~ run.group.hash) }}</a>
                            {% else %}
                                <span class="group-link">{{ run.group.name }}</span>
                            {% endif %}
                        </div>
                        {% endif %}
                        <div class="run-meta-section">
                        {% if run.start_time %}
                            <div class="meta-item">
                                <span class="meta-value start-time-display">{{ run.start_time }}</span>
                        </div>
                        {% endif %}
                            {% if run.start_time and run.end_time %}
                            <div class="meta-item">
                                <span class="meta-value duration-display" data-start="{{ run.start_time }}" data-end="{{ run.end_time }}"></span>
                        </div>
                        {% endif %}
                        <div class="meta-item">
                            <span class="run-execution-time execution-time" data-run-id="{{ run.run_id }}" style="display: none; font-size: 1.0em; color: #6c757d;"></span>
                        </div>
                        </div>
                    </td>

                    <td class="metadata-column">
                        {% if run.group and not group_context %}
                        {% for name, metadata in (run.group.metadata or {}).items() %}
                        <div class="meta-item">
                            <span class="meta-label">{{ name }}:</span>
                            <span class="meta-value">
                                {% if metadata.url %}
                                    <a href="{{ metadata.url }}" target="_blank">{{ metadata.value }}</a>
                                {% else %}
                                    {{ metadata.value }}
                                {% endif %}
                            </span>
                        </div>
                        {% endfor %}
                        {% endif %}
                        {% for name, metadata in (run.user_metadata or {}).items() %}
                        <div class="meta-item">
                            <span class="meta-label">{{ name }}:</span>
                            <span class="meta-value">
                                {% if metadata.url %}
                                    <a href="{{ metadata.url }}" target="_blank">{{ metadata.value }}</a>
                                {% else %}
                                    {{ metadata.value }}
                                {% endif %}
                            </span>
                        </div>
                        {% endfor %}
                    </td>

                    <td class="actions-column">
                            {% if run.status != 'running' %}
                                {% if run.files_exist %}
                                <a class="download-btn" href="/export/{{ run.run_id }}.zip">üì• Download ZIP</a>
                                {% else %}
                                <span class="download-btn disabled" title="Files have been cleaned up due to retention policy">üì• Download ZIP</span>
                                {% endif %}
                            {% endif %}
                        {% if run.retention_days and run.start_time %}
                        <div class="days-left" data-days="{{ run.retention_days }}" data-start="{{ run.start_time }}"></div>
                            {% endif %}
                    </td>
                </tr>
{% endfor %}
                </tbody>
            </table>

            {% if not runs_index %}
            <div class="empty-state">
                <i>üìã</i>
                <h3>No Test Runs Found</h3>
                <p>Start a test run to see it appear here.</p>
            </div>
            {% endif %}
        </div>
    </div>
<script>
  // Function to convert UTC time to local time
  function convertToLocalTime(utcTimeString) {
    if (!utcTimeString) return utcTimeString;
    try {
      const utcDate = new Date(utcTimeString);
      return utcDate.toLocaleString();
    } catch (e) {
      console.warn('Failed to parse time:', utcTimeString, e);
      return utcTimeString;
    }
  }

  // Function to convert all time elements to local time
  function convertTimesToLocal() {
    // Convert start times and end times in detail values
    document.querySelectorAll('.detail-item').forEach(item => {
      const label = item.querySelector('.detail-label');
      const value = item.querySelector('.detail-value');

      if (label && value) {
        const labelText = label.textContent.trim();
        const valueText = value.textContent.trim();

        // Only convert if it's a time field and looks like a timestamp
        if ((labelText === 'Start Time' || labelText === 'End Time') &&
            valueText && (valueText.includes('T') || valueText.includes('Z'))) {
          value.textContent = convertToLocalTime(valueText);
        }
      }
    });
  }

  function updateDaysLeft() {
    document.querySelectorAll('.days-left').forEach(function(span) {
      const days = parseInt(span.getAttribute('data-days'));
      const start = new Date(span.getAttribute('data-start'));
      const now = new Date();
      const msPerDay = 24 * 60 * 60 * 1000;
      const ageDays = Math.floor((now - start) / msPerDay);
      let daysLeft = days - ageDays;
      if (daysLeft < 0) daysLeft = 0;
      span.textContent = 'Days left: ' + daysLeft;
    });
  }

  // Function to calculate and display duration
  function updateDurations() {
    document.querySelectorAll('.duration-display').forEach(function(element) {
      const startTime = element.getAttribute('data-start');
      const endTime = element.getAttribute('data-end');

      if (startTime && endTime) {
        try {
          const start = new Date(startTime);
          const end = new Date(endTime);
          const duration = end - start;

          if (duration > 0) {
            const formattedDuration = formatExecutionTime(duration);
            element.textContent = `‚è±Ô∏è ${formattedDuration}`;
          }
        } catch (e) {
          console.warn('Failed to parse duration times:', startTime, endTime, e);
        }
      }
    });
  }

  // Convert times to local time on page load
  convertTimesToLocal();
  updateDaysLeft();
  updateDurations();
  setInterval(updateDaysLeft, 60 * 1000);

  function convertIndexTimestampsToLocal() {

    // Convert all start time displays
    const startElements = document.querySelectorAll('.start-time-display');

    startElements.forEach(element => {
      if (element.textContent && (element.textContent.includes('T') || element.textContent.includes('Z') || element.textContent.includes('-'))) {
        element.textContent = convertToLocalTime(element.textContent);
      }
    });

    // Convert all end time displays
    const endElements = document.querySelectorAll('.end-time-display');

    endElements.forEach(element => {
      if (element.textContent && (element.textContent.includes('T') || element.textContent.includes('Z') || element.textContent.includes('-'))) {
        element.textContent = convertToLocalTime(element.textContent);
      }
    });
  }

  // Initialize run execution times for pre-loaded runs
  document.addEventListener('DOMContentLoaded', function() {
    // Convert all timestamps to local time
    convertIndexTimestampsToLocal();

    // Set up hover history for statically rendered status badges
    if (typeof Classifications !== 'undefined') {
      document.querySelectorAll('.status-badge[data-group-hash]').forEach(badge => {
        const groupHash = badge.getAttribute('data-group-hash');
        const runId = badge.getAttribute('data-run-id');
        if (groupHash && runId) {
          Classifications.setupRunBadgeHistoryHover(badge, groupHash, runId);
        }
      });
    }

    const runExecutionTimeElements = document.querySelectorAll('.run-execution-time');

    runExecutionTimeElements.forEach(element => {
      const runId = element.getAttribute('data-run-id');

      // Try to find the run item to get execution time data
      const runItem = element.closest('[data-runid]');
      if (runItem) {
        // Look for start time and end time in the run details
        const startTimeElement = runItem.querySelector('.start-time-display');
        const durationDisplayElement = runItem.querySelector('.duration-display');
        const statusElement = runItem.querySelector('.status-badge');

        if (startTimeElement && statusElement) {
          const startTimeText = startTimeElement.textContent;
          const status = statusElement.textContent.toLowerCase();

          // Remove any duration-display elements since we use run-execution-time instead
          if (durationDisplayElement) {
            const durationItem = durationDisplayElement.closest('.meta-item');
            if (durationItem) {
              durationItem.remove();
            }
          }

          if (status.includes('running') && startTimeText) {
            // Run is running - start real-time tracking
            const startTime = new Date(startTimeText).getTime();
            if (!isNaN(startTime)) {
              runExecutionTimes.set(runId, {
                startTime: startTime,
                timer: setInterval(() => updateRunExecutionTime(runId), 1000)
              });
              showRunExecutionTime(runId);
            }
          } else if (durationDisplayElement) {
            // Run is finished - use the duration-display data attributes if available
            const startTimeAttr = durationDisplayElement.getAttribute('data-start');
            const endTimeAttr = durationDisplayElement.getAttribute('data-end');
            if (startTimeAttr && endTimeAttr) {
              showFinalRunExecutionTime(runId, startTimeAttr, endTimeAttr);
            }
          }
        }
      }
    });
  });

  // Resilient UI WebSocket connection with auto-reconnect and bfcache handling
  const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
  let ws;
  let reconnectDelayMs = 500;
  const maxDelayMs = 8000;

  // Run execution time tracking
  const runExecutionTimes = new Map(); // Track run execution times by run_id

  // Function to format execution time in human-readable format
  function formatExecutionTime(milliseconds) {
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }

  function updateRunExecutionTime(runId) {
    const runData = runExecutionTimes.get(runId);
    if (!runData || !runData.startTime) {
      return;
    }

    const now = Date.now();
    const elapsed = now - runData.startTime;
    const formattedTime = formatExecutionTime(elapsed);

    const executionTimeElement = document.querySelector(`.run-execution-time[data-run-id="${runId}"]`);
    if (executionTimeElement) {
      executionTimeElement.textContent = `‚è±Ô∏è ${formattedTime}`;
      executionTimeElement.style.display = 'inline';
    }
  }

  function showRunExecutionTime(runId) {
    const executionTimeElement = document.querySelector(`.run-execution-time[data-run-id="${runId}"]`);
    if (executionTimeElement) {
      executionTimeElement.style.display = 'inline';
    }
  }

  function showFinalRunExecutionTime(runId, startTime, endTime) {
    if (!startTime || !endTime) return;

    // Ensure both times are in proper ISO format
    let startTimeStr = startTime;
    let endTimeStr = endTime;

    // Add 'Z' to endTime if it doesn't have timezone info
    if (!endTimeStr.includes('Z') && !endTimeStr.includes('+') && !endTimeStr.includes('-', 10)) {
      endTimeStr += 'Z';
    }

    const start = new Date(startTimeStr);
    const end = new Date(endTimeStr);
    const duration = end - start;

    if (duration > 0) {
      const formattedTime = formatExecutionTime(duration);
      const executionTimeElement = document.querySelector(`.run-execution-time[data-run-id="${runId}"]`);
      if (executionTimeElement) {
        executionTimeElement.textContent = `‚è±Ô∏è ${formattedTime}`;
        executionTimeElement.style.display = 'inline';
      }
    }
  }

  function addOrUpdateRun(run) {
    try {
      if (!run || !run.run_id) { console.warn('Missing run or run_id', run); return; }
      const tbody = document.getElementById('runs-list');
      if (!tbody) { console.error('runs-list element not found'); return; }
      const isGroupContext = window.location.pathname.startsWith('/groups/');
      let tr = document.querySelector('tr[data-runid="' + run.run_id + '"]');
      let daysLeft = '';
      if (run.retention_days && run.start_time) {
        const start = new Date(run.start_time);
        const now = new Date();
        const msPerDay = 24 * 60 * 60 * 1000;
        const ageDays = Math.floor((now - start) / msPerDay);
        daysLeft = run.retention_days - ageDays;
        if (daysLeft < 0) daysLeft = 0;
      }
      if (!tr) {
        tr = document.createElement('tr');
        tr.className = 'run-item new-run';
        tr.setAttribute('data-runid', run.run_id);
        tbody.prepend(tr);

        // Remove the new-run class after animation completes
        setTimeout(() => {
          tr.classList.remove('new-run');
        }, 600);
      }

      // Clear existing content
      tr.innerHTML = '';

      // Create status column
      const statusColumn = document.createElement('td');
      statusColumn.className = 'status-column';

      // Create status badge
      let statusBadgeEl = null;
      if (run.status && run.status.toLowerCase() === 'aborted') {
        const abortedBadge = document.createElement('span');
        abortedBadge.className = 'status-badge status-aborted';
        abortedBadge.textContent = 'ABORTED';
        statusColumn.appendChild(abortedBadge);
        statusBadgeEl = abortedBadge;
      } else if (run.status && run.status.toLowerCase() === 'running') {
        const runningBadge = document.createElement('span');
        runningBadge.className = 'status-badge status-running';
        runningBadge.textContent = 'RUNNING ';
        const spinner = document.createElement('span');
        spinner.className = 'spinner';
        runningBadge.appendChild(spinner);
        statusColumn.appendChild(runningBadge);
        statusBadgeEl = runningBadge;
      } else {
        // Check if run has any running test cases
        const hasRunningTests = run.test_cases && Object.values(run.test_cases).some(tc =>
          tc.status && tc.status.toLowerCase() === 'running'
        );

        if (hasRunningTests) {
          const runningBadge = document.createElement('span');
          runningBadge.className = 'status-badge status-running';
          runningBadge.textContent = 'RUNNING ';
          const spinner = document.createElement('span');
          spinner.className = 'spinner';
          runningBadge.appendChild(spinner);
          statusColumn.appendChild(runningBadge);
          statusBadgeEl = runningBadge;
        } else {
          // Count test results to determine badge type
          // Note: aborted counts are combined into error counts
          let passedCount = run.passed_count || 0;
          let failedCount = run.failed_count || 0;
          let skippedCount = run.skipped_count || 0;
          let abortedCount = run.aborted_count || 0;
          let errorCount = run.error_count || 0;

          if (passedCount === 0 && failedCount === 0 && skippedCount === 0 && abortedCount === 0 && errorCount === 0 && run.test_cases) {
            for (const tcId in run.test_cases) {
              const tc = run.test_cases[tcId];
              if (!tc.status) continue;
              const s = tc.status.toLowerCase();
              if (s === 'passed') {
                passedCount++;
              } else if (s === 'failed') {
                failedCount++;
              } else if (s === 'skipped') {
                skippedCount++;
              } else if (s === 'aborted') {
                abortedCount++;
              } else if (s === 'error') {
                errorCount++;
              }
            }
          }

          // Combine aborted into error
          errorCount = errorCount + abortedCount;

          const finishedBadge = document.createElement('span');
          // Priority: Error (includes aborted) > Failed > Skipped (all) > Passed
          // If ALL tests are skipped (and no passed/failed/error)
          if (skippedCount > 0 && passedCount === 0 && failedCount === 0 && errorCount === 0) {
            finishedBadge.className = 'status-badge status-skipped';
            finishedBadge.textContent = 'SKIPPED';
          } else if (errorCount > 0) {
            finishedBadge.className = 'status-badge status-error';
            finishedBadge.textContent = 'ERROR';
          } else if (failedCount > 0) {
            finishedBadge.className = 'status-badge status-finished-failed';
            finishedBadge.textContent = 'FAILED';
          } else {
            finishedBadge.className = 'status-badge status-finished-passed';
            finishedBadge.textContent = 'PASSED';
          }
          statusColumn.appendChild(finishedBadge);
          statusBadgeEl = finishedBadge;
        }
      }

      // Add hover history for run status badge if we have a group
      const groupHash = run.group_hash || (run.group && run.group.hash);
      if (statusBadgeEl && groupHash && typeof Classifications !== 'undefined') {
        Classifications.setupRunBadgeHistoryHover(statusBadgeEl, groupHash, run.run_id);
      }

      // Create result badges container within status column
      const resultBadgesContainer = document.createElement('div');
      resultBadgesContainer.className = 'result-badges-container';

      // Count test results for badges - prefer direct counts from run object, otherwise count from test_cases
      // Note: aborted counts are combined into error counts
      let passedCount = run.passed_count || 0;
      let failedCount = run.failed_count || 0;
      let skippedCount = run.skipped_count || 0;
      let abortedCount = run.aborted_count || 0;
      let errorCount = run.error_count || 0;

      // If counts are not provided directly, count from test_cases
      if (passedCount === 0 && failedCount === 0 && skippedCount === 0 && abortedCount === 0 && errorCount === 0 && run.test_cases) {
        for (const tcId in run.test_cases) {
          const tc = run.test_cases[tcId];
          if (!tc.status) continue;
          const s = tc.status.toLowerCase();
          if (s === 'passed') {
            passedCount++;
          } else if (s === 'failed') {
            failedCount++;
          } else if (s === 'skipped') {
            skippedCount++;
          } else if (s === 'aborted') {
            abortedCount++;
          } else if (s === 'error') {
            errorCount++;
          }
        }
      }

      // Combine aborted into error
      errorCount = errorCount + abortedCount;
      abortedCount = 0;

      // Create result badges
      if (passedCount > 0) {
        const passedBadge = document.createElement('span');
        passedBadge.className = 'result-badge result-passed';
        passedBadge.title = 'Passed';
        passedBadge.textContent = passedCount;
        resultBadgesContainer.appendChild(passedBadge);
      }

      if (skippedCount > 0) {
        const skippedBadge = document.createElement('span');
        skippedBadge.className = 'result-badge result-skipped';
        skippedBadge.title = 'Skipped';
        skippedBadge.textContent = skippedCount;
        resultBadgesContainer.appendChild(skippedBadge);
      }

      if (failedCount > 0) {
        const failedBadge = document.createElement('span');
        failedBadge.className = 'result-badge result-failed';
        failedBadge.title = 'Failed';
        failedBadge.textContent = failedCount;
        resultBadgesContainer.appendChild(failedBadge);
      }

      if (errorCount > 0) {
        const errorBadge = document.createElement('span');
        errorBadge.className = 'result-badge result-error';
        errorBadge.title = 'Error';
        errorBadge.textContent = errorCount;
        resultBadgesContainer.appendChild(errorBadge);
      }

      // Always add result badges container (even if empty initially)
      statusColumn.appendChild(resultBadgesContainer);

      // Create title column
      const titleColumn = document.createElement('td');
      titleColumn.className = 'title-column';

      const title = document.createElement('h3');
      title.className = 'run-title';
      const link = document.createElement('a');
      link.href = `/testRun/${run.run_id}/index.html`;
      link.className = 'run-link';
      link.textContent = run.run_name;
      title.appendChild(link);

      // Create run meta section for start time and duration
      const runMetaSection = document.createElement('div');
      runMetaSection.className = 'run-meta-section';

      // Start time
      if (run.start_time) {
        const startItem = document.createElement('div');
        startItem.className = 'meta-item';
        const startValue = document.createElement('span');
        startValue.className = 'meta-value start-time-display';
        startValue.textContent = convertToLocalTime(run.start_time);
        startItem.appendChild(startValue);
        runMetaSection.appendChild(startItem);
      }

      // Add execution time element to run-meta-section
      // This will be used for both running (real-time) and finished runs
      const executionTimeItem = document.createElement('div');
      executionTimeItem.className = 'meta-item';

      const executionTimeSpan = document.createElement('span');
      executionTimeSpan.className = 'run-execution-time execution-time';
      executionTimeSpan.setAttribute('data-run-id', run.run_id);
      executionTimeSpan.style.display = 'none';
      executionTimeSpan.style.fontSize = '1.0em';
      executionTimeSpan.style.color = '#6c757d';

      executionTimeItem.appendChild(executionTimeSpan);
      runMetaSection.appendChild(executionTimeItem);

      // Add title, then group pill, then meta section to title column (matching template order)
      titleColumn.appendChild(title);

      // Add group pill if group exists and we're not in a group context (similar to template)
      if (run.group && (run.group.name || run.group.hash) && !isGroupContext) {
        const groupPill = document.createElement('div');
        groupPill.className = 'group-pill';
        const groupLabel = document.createElement('span');
        groupLabel.textContent = 'Group:';
        groupPill.appendChild(groupLabel);
        if (run.group.hash) {
          const groupLink = document.createElement('a');
          groupLink.href = `/groups/${run.group.hash}`;
          groupLink.className = 'group-link';
          groupLink.textContent = run.group.name || `Group ${run.group.hash}`;
          groupPill.appendChild(groupLink);
        } else {
          const groupSpan = document.createElement('span');
          groupSpan.className = 'group-link';
          groupSpan.textContent = run.group.name;
          groupPill.appendChild(groupSpan);
        }
        titleColumn.appendChild(groupPill);
      }

      if (runMetaSection.children.length > 0) {
        titleColumn.appendChild(runMetaSection);
      }

      // Create metadata column for group + user metadata
      const metadataColumn = document.createElement('td');
      metadataColumn.className = 'metadata-column';

      const appendMetadataItem = (label, metadata) => {
        const metaItem = document.createElement('div');
        metaItem.className = 'meta-item';
        const metaLabel = document.createElement('span');
        metaLabel.className = 'meta-label';
        metaLabel.textContent = `${label}:`;
        const metaValue = document.createElement('span');
        metaValue.className = 'meta-value';
        if (metadata && metadata.url) {
          const link = document.createElement('a');
          link.href = metadata.url;
          link.target = '_blank';
          link.textContent = metadata.value;
          metaValue.appendChild(link);
        } else if (metadata && metadata.value !== undefined) {
          metaValue.textContent = metadata.value;
        } else {
          metaValue.textContent = '';
        }
        metaItem.appendChild(metaLabel);
        metaItem.appendChild(metaValue);
        metadataColumn.appendChild(metaItem);
      };

      // Only show group metadata items (not the group name itself) in metadata column if we're not in a group context
      // The group name is shown as a pill in the title column, not here
      if (run.group && !isGroupContext && run.group.metadata) {
        for (const [name, metadata] of Object.entries(run.group.metadata)) {
          appendMetadataItem(name, metadata);
        }
      }

      if (run.user_metadata) {
        for (const [name, metadata] of Object.entries(run.user_metadata)) {
          appendMetadataItem(name, metadata);
        }
      }

      // Create actions column
      const actionsColumn = document.createElement('td');
      actionsColumn.className = 'actions-column';

      // Only show download button if run is not currently running
      if (run.status !== 'running') {
        // Check if files exist (assume true for WebSocket updates of recent runs)
        const filesExist = run.files_exist !== false; // Default to true if not specified

        if (filesExist) {
          const downloadBtn = document.createElement('a');
          downloadBtn.className = 'download-btn';
          downloadBtn.href = `/export/${run.run_id}.zip`;
          downloadBtn.textContent = 'üì• Download ZIP';
          actionsColumn.appendChild(downloadBtn);
        } else {
          const downloadBtn = document.createElement('span');
          downloadBtn.className = 'download-btn disabled';
          downloadBtn.title = 'Files have been cleaned up due to retention policy';
          downloadBtn.textContent = 'üì• Download ZIP';
          actionsColumn.appendChild(downloadBtn);
        }
      }

      // Add days left to actions column if applicable
      if (run.retention_days && run.start_time) {
        const daysDiv = document.createElement('div');
        daysDiv.className = 'days-left';
        daysDiv.setAttribute('data-days', run.retention_days);
        daysDiv.setAttribute('data-start', run.start_time);
        daysDiv.textContent = `Days left: ${daysLeft}`;
        actionsColumn.appendChild(daysDiv);
      }

      // Assemble the item
      tr.appendChild(statusColumn);
      tr.appendChild(titleColumn);
      tr.appendChild(metadataColumn);
      tr.appendChild(actionsColumn);

      // Handle run execution time

      // Handle run execution time
      if (run.status && run.status.toLowerCase() === 'running' && run.start_time) {
        // For index page, we don't have access to individual test case start times
        // So we'll use the run start time, but this might show longer durations
        runExecutionTimes.set(run.run_id, {
          startTime: new Date(run.start_time).getTime(),
          timer: setInterval(() => updateRunExecutionTime(run.run_id), 1000)
        });
        showRunExecutionTime(run.run_id);
      } else if (run.start_time && run.end_time) {
        // Run is finished - remove any duration-display elements and show final execution time
        const runItem = document.querySelector(`tr[data-runid="${run.run_id}"]`);
        if (runItem) {
          const durationDisplayElement = runItem.querySelector('.duration-display');
          if (durationDisplayElement) {
            const durationItem = durationDisplayElement.closest('.meta-item');
            if (durationItem) {
              durationItem.remove();
            }
          }
        }
        // Show final execution time
        showFinalRunExecutionTime(run.run_id, run.start_time, run.end_time);
        // Clear any existing timer
        const existingData = runExecutionTimes.get(run.run_id);
        if (existingData && existingData.timer) {
          clearInterval(existingData.timer);
          runExecutionTimes.delete(run.run_id);
        }
      }

      // Add status update animation if this is an existing run that was updated
      if (tr.classList.contains('run-item') && !tr.classList.contains('new-run')) {
        tr.classList.add('status-updated');
        setTimeout(() => {
          tr.classList.remove('status-updated');
        }, 800);
      }

    } catch (err) {
      console.error('addOrUpdateRun failed', err, run);
    }
  }

  function handleMessage(event) {
    try {
      const msg = JSON.parse(event.data);
      if (msg.type === 'run_started' || msg.type === 'run_updated' || msg.type === 'run_finished' || msg.type === 'run_timeout') {
        addOrUpdateRun(msg.run);
      } else if (msg.type === 'test_case_started' || msg.type === 'test_case_updated' || msg.type === 'test_case_finished') {
        // For test case updates, only update the result badges with the new counts
        if (msg.counts) {
          updateResultBadges(msg.run_id, msg.counts);
        }
      }
    } catch(e) { console.error('WS message parse error', e); }
  }

  function updateResultBadges(runId, counts) {
    const tr = document.querySelector('tr[data-runid="' + runId + '"]');
    if (!tr) return;

    const resultBadgesContainer = tr.querySelector('.status-column .result-badges-container');
    if (!resultBadgesContainer) return;

    // Clear existing result badges
    resultBadgesContainer.innerHTML = '';

    // Create new badges based on counts
    if (counts.passed > 0) {
      const passedBadge = document.createElement('span');
      passedBadge.className = 'result-badge result-passed';
      passedBadge.title = 'Passed';
      passedBadge.textContent = counts.passed;
      resultBadgesContainer.appendChild(passedBadge);
    }

    if (counts.skipped > 0) {
      const skippedBadge = document.createElement('span');
      skippedBadge.className = 'result-badge result-skipped';
      skippedBadge.title = 'Skipped';
      skippedBadge.textContent = counts.skipped;
      resultBadgesContainer.appendChild(skippedBadge);
    }

      if (counts.failed > 0) {
        const failedBadge = document.createElement('span');
        failedBadge.className = 'result-badge result-failed';
        failedBadge.title = 'Failed';
        failedBadge.textContent = counts.failed;
        resultBadgesContainer.appendChild(failedBadge);
      }

      // Combine aborted into error
      const totalErrorCount = (counts.error || 0) + (counts.aborted || 0);
      if (totalErrorCount > 0) {
        const errorBadge = document.createElement('span');
        errorBadge.className = 'result-badge result-error';
        errorBadge.title = 'Error';
        errorBadge.textContent = totalErrorCount;
        resultBadgesContainer.appendChild(errorBadge);
      }

      // Update the leftmost status badge based on counts
      const statusBadge = tr.querySelector('.status-badge');
      if (statusBadge && (statusBadge.textContent.trim() === 'FINISHED' || statusBadge.textContent.trim() === 'PASSED' || statusBadge.textContent.trim() === 'FAILED' || statusBadge.textContent.trim() === 'SKIPPED' || statusBadge.textContent.trim() === 'ERROR')) {
        // Priority: Error (includes aborted) > Failed > Skipped (all) > Passed
        const totalError = (counts.error || 0) + (counts.aborted || 0);
        if (counts.skipped > 0 && counts.passed === 0 && counts.failed === 0 && totalError === 0) {
          statusBadge.className = 'status-badge status-skipped';
          statusBadge.textContent = 'SKIPPED';
        } else if (totalError > 0) {
          statusBadge.className = 'status-badge status-error';
          statusBadge.textContent = 'ERROR';
        } else if (counts.failed > 0) {
          statusBadge.className = 'status-badge status-finished-failed';
          statusBadge.textContent = 'FAILED';
        } else {
          statusBadge.className = 'status-badge status-finished-passed';
          statusBadge.textContent = 'PASSED';
        }
      }
  }

  function connectUIWS() {
    try {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
      ws = new WebSocket(`${scheme}://${location.host}/ws/ui`);
      ws.onopen = () => { reconnectDelayMs = 500; };
      ws.onmessage = handleMessage;
      ws.onerror = () => {};
      ws.onclose = () => {
        setTimeout(connectUIWS, reconnectDelayMs);
        reconnectDelayMs = Math.min(maxDelayMs, reconnectDelayMs * 2);
      };
    } catch (e) {
      setTimeout(connectUIWS, reconnectDelayMs);
      reconnectDelayMs = Math.min(maxDelayMs, reconnectDelayMs * 2);
    }
  }

  // Initial connect
  connectUIWS();
  // Reconnect when coming back via back/forward cache
  window.addEventListener('pageshow', () => { connectUIWS(); });
</script>
</body>
</html>