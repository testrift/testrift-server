<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Test Run - {{ run_name or run_id }}</title>
    <script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
    {% if server_mode %}
    <script src="/static/msgpack.min.js"></script>
    <link href="/static/status-badges.css" rel="stylesheet">
    <link href="/static/classifications.css" rel="stylesheet">
    <script src="/static/classifications.js"></script>
    {% else %}
    <script src="static/msgpack.min.js"></script>
    <link href="static/status-badges.css" rel="stylesheet">
    <link href="static/classifications.css" rel="stylesheet">
    <script src="static/classifications.js"></script>
    {% endif %}
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .main-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin: 20px auto;
            padding: 0;
            overflow: hidden;
        }

        .header-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header-section h1 {
            margin: 0;
            font-size: 3em;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header-section .subtitle {
            font-size: 1.4em;
            opacity: 0.9;
            margin-top: 10px;
        }

        .content-section {
            padding: 30px;
        }

        .run-info {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: none;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .run-info h3 {
            color: #495057;
            margin-bottom: 20px;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        /* Run-level status badge (larger) - inherits from shared CSS, override size */
        .run-info .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 1em;
            min-width: 100px;
        }

        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .run-title-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .run-timing-row {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.9em;
            color: #6c757d;
        }

        .run-status-section {
            display: flex;
            justify-content: flex-end;
            align-items: center;
        }

        .status-badge-top {
            display: inline-flex;
            align-items: center;
        }

        .run-bottom-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }

        .download-section {
            display: flex;
            align-items: center;
        }

        /* Result badges - larger size for run header, colors from shared CSS */
        .run-info .result-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        /* Status badge color overrides for run-level - use shared CSS */

        .download-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-block;
            margin-right: 10px;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
            color: white;
            text-decoration: none;
        }

        .download-btn.disabled {
            background: #6c757d;
            color: #adb5bd;
            cursor: not-allowed;
            box-shadow: none;
        }

        .download-btn.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .info-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .info-item strong {
            color: #667eea;
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .run-id-value {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #6c757d;
        }

        .group-link {
            font-weight: 600;
            color: #4c7fff;
        }

        .test-cases-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .test-cases-header h2 {
            margin: 0;
            color: #495057;
            font-weight: 600;
        }


        .expand-collapse-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .expand-collapse-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        #collapse-all-btn {
            background: #6c757d;
        }

        #collapse-all-btn:hover {
            background: #5a6268;
        }

        #test-live-indicator {
            background: #17a2b8;
        }

        #test-live-indicator:hover {
            background: #138496;
        }

        #expand-all-btn:hover {
            background: #218838;
        }

        .tree, .tree ul {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        #test-cases-list {
            max-width: 100%;
            position: relative;
            /* --tc-status-left is set dynamically by JavaScript to align all status badges */
        }

        /* List view styling */
        .list-view {
            list-style: none;
            padding: 0;
            margin: 0;
            max-width: 80%;
        }

        .list-view li {
            padding: 4px 8px;   /* tighter vertical & horizontal padding */
            margin: 1px 0;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9em;  /* match tree view TC name size */
        }

        .list-view li:hover {
            background: #e9ecef;
        }

        .list-view li a {
            color: #007bff;
            text-decoration: none;
            flex-grow: 1;
        }

        .list-view li a:hover {
            text-decoration: underline;
        }

        .list-view li span[title*="cleaned up"] {
            color: #6c757d;
            cursor: not-allowed;
            flex-grow: 1;
        }

        .list-view .list-left {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-width: 0;
            max-width: calc(var(--tc-status-left, 400px) - 16px);
        }

        .list-view .list-left > a,
        .list-view .list-left > span {
            display: inline-block;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* List view right side (badge, time, classification) - absolute positioned like .tc-right */
        .list-view-right {
            position: absolute;
            left: var(--tc-status-left, 400px);
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            min-width: var(--tc-right-width, 200px);
        }

        /* Sort select styling */
        .sort-select {
            padding: 6px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background: white;
            color: #495057;
            font-size: 14px;
            cursor: pointer;
            min-width: 120px;
        }

        .sort-select:hover {
            border-color: #28a745;
        }

        .sort-select:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.25);
        }

        .status-filter-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .status-filter-container label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8em;
            border-radius: 15px;
            padding: 6px 12px;
            cursor: pointer;
            border: none;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .status-filter-container input {
            accent-color: #28a745;
            margin: 0;
        }

        .status-filter-container label:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .status-filter-passed {
            background: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }

        .status-filter-failed {
            background: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }

        .status-filter-skipped {
            background: #fff3cd;
            color: #856404;
            border-color: #ffeeba;
        }

        .status-filter-error {
            background: #e2e3e5;
            color: #6c757d;
            border-color: #d6d8db;
        }

        .tree ul {
            margin-left: 1.5em;      /* original indent behaviour */
            padding-left: 0;
            border-left: 2px solid #e9ecef;
            margin-top: 5px;
        }

        .tree li {
            margin: 0;
            padding: 0;              /* no left/right padding so badges align */
            line-height: 1.2;
            font-weight: 500;
            font-size: 1em;
            background: transparent;
            margin-bottom: 1px;
            border-radius: 4px;
            box-shadow: none;
        }

        /* Single child styling - less cluttered appearance */
        .tree li.single-child {
            padding: 0;
            margin-bottom: 1px;
        }

        .tc-row {
            display: flex;
            align-items: center;
            width: 100%;
        }

        .tc-main {
            display: inline-flex;
            align-items: center;
            min-width: 0;
            flex: 0 1 auto;
            font-size: 0.9em;  /* controls TC name size in tree view */
            overflow: hidden;
            max-width: calc(var(--tc-status-left, 400px) - var(--tc-indent, 0px));
        }

        .tc-main > a,
        .tc-main > span:first-child {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 1;
        }

        .tc-right {
            position: absolute;
            left: var(--tc-status-left, 400px);
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            min-width: var(--tc-right-width, 200px);
        }

        /* Badge styling */
        .tc-right .badge {
            min-width: 65px;
            text-align: center;
        }

        /* Running badges need flex layout to properly show spinner */
        .tc-right .badge.bg-running {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .list-view-right .badge.bg-running {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .tc-right .execution-time {
            margin-left: 6px;
        }

        .tc-right .classification-container {
            margin-left: 4px;
        }

        .tc-right .collapsed-classification-container {
            margin-left: 4px;
        }

        /* Hover effect for all li elements */
        .tree li:hover {
            background: rgba(102, 126, 234, 0.08);
        }

        .tree li a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .tree li a:hover {
            color: #764ba2;
            text-decoration: none;
        }

        .indicator {
            margin-right: 10px;
            cursor: pointer;
            color: #667eea;
            font-size: 1.3em;
            transition: color 0.3s ease;
        }

        .indicator:hover {
            color: #764ba2;
        }

        .badge {
            margin-left: 10px;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            min-width: 65px;
            text-align: center;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        /* bg-* colors are in shared status-badges.css */

        /* Collapsed classification container for parent nodes */
        .collapsed-classification-container {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 4px;
        }

        /* Remove individual icon margins inside collapsed container */
        .collapsed-classification-container .classification-icon,
        .collapsed-classification-container .new-tc-indicator {
            margin-left: 0;
        }

        .collapsed-classification-container .classification-icon {
            width: 16px;
            height: 16px;
            font-size: 12px;
        }

        .collapsed-classification-container .new-tc-indicator {
            width: 14px;
            height: 14px;
            font-size: 12px;
        }

        .spinner {
            width: 12px;
            height: 12px;
            border: 2px solid #000;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state i {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        @media (max-width: 768px) {
            .main-container {
                margin: 10px;
                border-radius: 10px;
            }

            .header-section {
                padding: 20px;
            }

            .header-section h1 {
                font-size: 2em;
            }

            .content-section {
                padding: 20px;
            }

            .run-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .run-status-section {
                justify-content: flex-start;
                width: 100%;
            }

            .run-bottom-section {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .result-badges-container {
                flex-wrap: wrap;
            }

            .test-cases-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .test-cases-header > div {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .expand-collapse-btn {
                font-size: 0.75em;
                padding: 5px 10px;
            }
        }

    /* Animated dots for live indicator */
    .dots {
        display: inline-block;
    }

    .dot {
        display: inline-block;
        animation: jump 1.4s infinite;
    }

    .dot:nth-child(1) {
        animation-delay: 0s;
    }

    .dot:nth-child(2) {
        animation-delay: 0.2s;
    }

    .dot:nth-child(3) {
        animation-delay: 0.4s;
    }

    @keyframes jump {
        0%, 80%, 100% {
            transform: translateY(0);
            opacity: 0.3;
        }
        40% {
            transform: translateY(-3px);
            opacity: 1;
            }
        }

    /* Metrics Section Styles */
    .metrics-section {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 12px;
        padding: 15px 20px;
        margin-bottom: 25px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    }

    .metrics-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .metrics-legend {
        display: flex;
        gap: 15px;
        font-size: 0.85em;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
        color: #6c757d;
    }

    .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
    }

    .cpu-color {
        background-color: #667eea;
    }

    .mem-color {
        background-color: #28a745;
    }

    .net-color {
        background-color: #e67e22;
    }

    .metrics-chart-container {
        background: white;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 10px;
    }

    #metrics-chart {
        width: 100% !important;
        height: 80px !important;
    }

    .metrics-summary {
        display: flex;
        gap: 30px;
        font-size: 0.85em;
        color: #6c757d;
    }

    .metric-stat {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .metric-label {
        font-weight: 600;
        color: #495057;
    }

    .metric-value {
        font-family: 'Courier New', monospace;
    }
    </style>
</head>
<body>
    {% if not server_mode %}
        {% include 'static_banner.html' %}
    {% endif %}

    <div class="main-container">
        <div class="header-section">
            <h1>Test Run</h1>
            <div class="subtitle">Test Execution Details</div>
        </div>

        <div class="content-section">
            <div class="run-info">
                <div class="run-header">
                    <div class="run-title-section">
                        <h3 class="run-name" style="margin: 0 0 4px 0;">{{ run_name or run_id }}</h3>
                        <div class="run-timing-row">
                            <span id="start-time-display">{{ start_time }}</span>
                            <span id="run-execution-time" class="execution-time" style="display: none;"></span>
                        </div>
                    </div>
                    <div class="run-status-section">
                        <div class="status-badge-top">
                        {% if status.lower() == 'running' %}
                            <span id="run-status" class="status-badge status-badge-lg status-running">
                                RUNNING <span class="status-spinner"></span>
                            </span>
                            {% elif status.lower() == 'aborted' %}
                            <span class="status-badge status-aborted" {% if abort_reason %}title="{{ abort_reason }}"{% endif %}>ABORTED</span>
                            {% else %}
                            {% if skipped_count > 0 and passed_count == 0 and failed_count == 0 and (error_count is not defined or error_count == 0) %}
                            <span class="status-badge status-skipped">SKIPPED</span>
                            {% elif error_count is defined and error_count > 0 %}
                            <span class="status-badge status-error">ERROR</span>
                            {% elif failed_count > 0 %}
                            <span class="status-badge status-finished-failed">FAILED</span>
                            {% else %}
                            <span class="status-badge status-finished-passed">PASSED</span>
                            {% endif %}
                            {% endif %}
                        </div>
                    </div>
                </div>

                <div class="info-grid">
                    {% if group %}
                    <div class="info-item">
                        <strong>Group</strong>
                        {% if group.hash %}
                            <a href="/groups/{{ group.hash }}" class="group-link">{{ group.name or ('Group ' ~ group.hash) }}</a>
                        {% else %}
                            {{ group.name }}
                        {% endif %}
                    </div>
                    {% for name, metadata in (group.metadata or {}).items() %}
                    <div class="info-item">
                        <strong>{{ name }}</strong>
                        {% if metadata.url %}
                            <a href="{{ metadata.url }}" target="_blank">{{ metadata.value }}</a>
                        {% else %}
                            {{ metadata.value }}
                        {% endif %}
                    </div>
                    {% endfor %}
                    {% endif %}
                    {% for name, metadata in user_metadata.items() %}
                    <div class="info-item">
                        <strong>{{ name }}</strong>
                        {% if metadata.url %}
                            <a href="{{ metadata.url }}" target="_blank">{{ metadata.value }}</a>
                        {% else %}
                            {{ metadata.value }}
                        {% endif %}
                    </div>
                    {% endfor %}
                </div>

                <div class="run-bottom-section">
                    <div class="download-section">
                        {% if not live_run %}
                            {% if files_exist %}
                            <a href="/export/{{ run_id }}.zip" class="download-btn">ðŸ“¥ Download ZIP</a>
                            {% else %}
                            <span class="download-btn disabled" title="Files have been cleaned up due to retention policy">ðŸ“¥ Download ZIP</span>
                            {% endif %}
                        {% endif %}
                    </div>
                    <div id="run-status-container" class="result-badges-container">
                        {% if passed_count > 0 %}
                        <span class="result-badge result-passed">PASSED: {{ passed_count }}</span>
                        {% endif %}
                        {% if skipped_count > 0 %}
                        <span class="result-badge result-skipped">SKIPPED: {{ skipped_count }}</span>
                        {% endif %}
                        {% if failed_count > 0 %}
                        <span class="result-badge result-failed">FAILED: {{ failed_count }}</span>
                        {% endif %}
                        {% if error_count is defined and error_count > 0 %}
                        <span class="result-badge result-error">ERROR: {{ error_count }}</span>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- System Metrics Chart -->
            <div class="metrics-section" id="metrics-section" style="display: none;">
                <div class="metrics-header">
                    <h4 style="margin: 0; color: #495057; font-weight: 600;">System Metrics</h4>
                    <div class="metrics-legend">
                        <span class="legend-item"><span class="legend-color cpu-color"></span> CPU</span>
                        <span class="legend-item"><span class="legend-color mem-color"></span> Memory</span>
                        <span class="legend-item"><span class="legend-color net-color"></span> Network</span>
                    </div>
                </div>
                <div class="metrics-chart-container" style="position: relative;">
                    <canvas id="metrics-chart" height="80"></canvas>
                    <div id="metrics-tooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.92); color: white; padding: 10px 14px; border-radius: 6px; font-size: 12px; z-index: 1000; max-width: 500px;"></div>
                </div>
                <div class="metrics-summary" id="metrics-summary">
                    <div class="metric-stat">
                        <span class="metric-label">CPU:</span>
                        <span class="metric-value" id="cpu-min">-</span> min /
                        <span class="metric-value" id="cpu-avg">-</span> avg /
                        <span class="metric-value" id="cpu-max">-</span> max
                    </div>
                    <div class="metric-stat">
                        <span class="metric-label">Memory:</span>
                        <span class="metric-value" id="mem-min">-</span> min /
                        <span class="metric-value" id="mem-avg">-</span> avg /
                        <span class="metric-value" id="mem-max">-</span> max
                    </div>
                    <div class="metric-stat">
                        <span class="metric-label">Network:</span>
                        <span class="metric-value" id="net-min">-</span> min /
                        <span class="metric-value" id="net-avg">-</span> avg /
                        <span class="metric-value" id="net-max">-</span> max
                    </div>
                </div>
            </div>

            <div class="test-cases-header">
                <h2>Test Cases</h2>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div class="status-filter-container" style="display:flex; gap:8px; align-items:center;">
                        <label class="status-filter-passed">
                            <input type="checkbox" id="filter-passed" checked>
                            Passed
                        </label>
                        <label class="status-filter-failed">
                            <input type="checkbox" id="filter-failed" checked>
                            Failed
                        </label>
                        <label class="status-filter-skipped">
                            <input type="checkbox" id="filter-skipped" checked>
                            Skipped
                        </label>
                        <label class="status-filter-error">
                            <input type="checkbox" id="filter-error" checked>
                            Error
                        </label>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button id="view-toggle-btn" class="expand-collapse-btn">List View</button>
                        <button id="expand-all-btn" class="expand-collapse-btn">Expand All</button>
                        <button id="collapse-all-btn" class="expand-collapse-btn">Collapse All</button>
                        <select id="sort-select" class="sort-select">
                            <option value="received">Order Received</option>
                            <option value="asc">A-Z</option>
                            <option value="desc">Z-A</option>
                        </select>
                    </div>
                </div>
            </div>

            <ul id="test-cases-list" class="tree">
                <!-- Test cases will be populated by JavaScript tree building -->
            </ul>
        </div>
    </div>
    <script>
        // Template configuration for JavaScript
        const runConfig = {
            runId: {{ run_id | tojson }},
            groupHash: {{ (group.hash if group else None) | tojson }},
            serverMode: {{ server_mode | tojson if server_mode is defined else 'true' }},
            liveRun: {{ live_run | tojson }}
        };

        // Metrics data from server (initial load)
        let metricsData = {{ metrics | tojson if metrics is defined else '[]' }};

        // Downsample initial metrics if too many
        function downsampleMetricsInitial() {
            const maxSamples = 2000;
            while (metricsData.length > maxSamples) {
                const result = [];
                for (let i = 0; i < metricsData.length - 1; i += 2) {
                    const m1 = metricsData[i];
                    const m2 = metricsData[i + 1];
                    result.push({
                        ts: Math.round((m1.ts + m2.ts) / 2),
                        cpu: Math.round(((m1.cpu + m2.cpu) / 2) * 10) / 10,
                        mem: Math.round(((m1.mem + m2.mem) / 2) * 10) / 10,
                        net: Math.round(((m1.net || 0) + (m2.net || 0)) / 2 * 10) / 10,
                        ni: m1.ni || m2.ni
                    });
                }
                if (metricsData.length % 2 === 1) {
                    result.push(metricsData[metricsData.length - 1]);
                }
                metricsData = result;
            }
        }
        downsampleMetricsInitial();

        // Classification data storage
        let classificationsData = {};

        let lastScript = null;
        let testMap = new Map();
        let root = null;
        let isCollapseAllActive = false;
        let isListView = false;
        let collapsedNodes = new Set(); // Track collapsed nodes by fullName
        let currentSortOrder = 'received';
        let testCaseOrder = []; // Track the order test cases were received
        let runningTests = new Map(); // Track running tests: Map<testId, {startTime: number, testId: string}>
        let executionTimer = null;
        let runStartTime = null;
        let runExecutionTimer = null;
        const STATUS_FILTER_STORAGE_KEY = 'testRunStatusFilters';
        const STATUS_FILTER_KEYS = ['passed', 'failed', 'skipped', 'error'];

        // Debounce variables for incremental updates
        let pendingViewRebuild = false;
        let viewRebuildDebounceTimer = null;
        const VIEW_REBUILD_DEBOUNCE_MS = 200;
        const LOG_URL_BASE = "{% if live_run %}/testRun/{{ run_id }}/log/{% else %}log/{% endif %}";
        let statusFilters = {
            passed: true,
            failed: true,
            skipped: true,
            error: true
        };

        // Real-time execution time tracking
        function startExecutionTimer() {
            if (executionTimer) return; // Already running

            executionTimer = setInterval(() => {
                updateRunningTestTimes();
            }, 1000); // Update every second
        }

        function stopExecutionTimer() {
            if (executionTimer) {
                clearInterval(executionTimer);
                executionTimer = null;
            }
        }

        // Helper function to find a test entry in the tree by fullName or originalFullName
        function findTestEntryInTree(node, searchKey) {
            if (!node) return null;

            if (node.traceHtmlFile) {
                if (node.fullName === searchKey ||
                    (node.originalFullName && node.originalFullName === searchKey) ||
                    (node.originalEntry && node.originalEntry.fullName === searchKey)) {
                    return node;
                }
            }

            if (node.children && node.children.length > 0) {
                for (let child of node.children) {
                    const found = findTestEntryInTree(child, searchKey);
                    if (found) return found;
                }
            }

            return null;
        }

        function findTestMapEntry(testId) {
            if (!testId) return null;
            if (testMap.has(testId)) return testMap.get(testId);

            let result = null;
            testMap.forEach((entry, key) => {
                if (result) return;
                if (key === testId || entry.fullName === testId || entry.originalFullName === testId) {
                    result = entry;
                }
            });
            return result;
        }

        function getTestEntryContext(testId) {
            const original = findTestMapEntry(testId);
            const treeEntry = root ? findTestEntryInTree(root, testId) : null;
            const entry = treeEntry || original || null;
            const resolvedOriginal = original || (entry && entry.originalEntry) || null;
            return { entry, original: resolvedOriginal };
        }

        function ensureExecutionTimeElement(entry) {
            if (!entry) return null;

            let element = entry.executionTimeElement;

            if (!element || element.length === 0 || !element.parent().length) {
                // Try to reuse existing element in DOM
                const existing = entry.listItem.find(".execution-time");
                if (existing.length > 0) {
                    element = existing;
                } else if (entry.traceHtmlFile) {
                    element = $("<span>").addClass("execution-time").css({
                        "font-size": "0.85em",
                        "color": "#6c757d",
                        "display": "inline"
                    });
                }

                entry.executionTimeElement = element;

                if (element && element.length > 0 && !element.parent().length) {
                    const tcMain = entry.listItem.find(".tc-main");
                    if (tcMain.length > 0 && entry.textElement && entry.textElement.length > 0) {
                        entry.textElement.after(element);
                    } else if (tcMain.length > 0) {
                        tcMain.append(element);
                    } else {
                        entry.listItem.append(element);
                    }
                }
            }

            return (element && element.length > 0) ? element : null;
        }

        function parseStartTime(raw) {
            if (!raw) return null;
            const timestamp = new Date(raw).getTime();
            return Number.isFinite(timestamp) ? timestamp : null;
        }

        function updateRunningTestTimes() {
            const now = Date.now();
            if (runningTests.size === 0) {
                return; // No running tests to update
            }
            runningTests.forEach((timerData, testId) => {
                const canonicalId = timerData.testId || testId;
                let startTime = timerData.startTime;
                if (!Number.isFinite(startTime)) {
                    startTime = Date.now();
                }
                const { entry, original } = getTestEntryContext(canonicalId);

                if (!entry) {
                    runningTests.delete(testId);
                    if (canonicalId !== testId) runningTests.delete(canonicalId);
                    return;
                }

                if (original && !entry.listViewExecutionTimeElement && original.listViewExecutionTimeElement) {
                    entry.listViewExecutionTimeElement = original.listViewExecutionTimeElement;
                }

                const status = (entry.Status || (original ? original.Status : '') || '').toLowerCase();
                if (status !== 'running') {
                    runningTests.delete(testId);
                    if (canonicalId !== testId) runningTests.delete(canonicalId);
                    return;
                }

                const elapsed = now - startTime;
                const formattedTime = formatExecutionTime(elapsed);
                const execTimeElement = ensureExecutionTimeElement(entry);

                if (execTimeElement) {
                    execTimeElement.text(`â±ï¸ ${formattedTime}`).css("display", "inline");
                }
                if (entry.listViewExecutionTimeElement) {
                    entry.listViewExecutionTimeElement.textContent = `â±ï¸ ${formattedTime}`;
                }
            });

            // Stop timer if no tests are running
            if (runningTests.size === 0) {
                stopExecutionTimer();
            }
        }

        // Function to format execution time in human-readable format
        function formatExecutionTime(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);

            if (hours > 0) {
                return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds % 60}s`;
            } else {
                return `${seconds}s`;
            }
        }

        function formatExecutionTimeWithMillis(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const ms = Math.floor(milliseconds % 1000);
            const seconds = totalSeconds % 60;
            const minutes = Math.floor(totalSeconds / 60) % 60;
            const hours = Math.floor(totalSeconds / 3600);
            const msStr = String(ms).padStart(3, '0');

            if (hours > 0) {
                return `${hours}h ${minutes}m ${seconds}.${msStr}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds}.${msStr}s`;
            }
            return `${seconds}.${msStr}s`;
        }

        // Run execution time tracking functions
        function startRunExecutionTimer() {
            if (runExecutionTimer) return; // Already running

            runExecutionTimer = setInterval(() => {
                updateRunExecutionTime();
            }, 1000);
        }

        function stopRunExecutionTimer() {
            if (runExecutionTimer) {
                clearInterval(runExecutionTimer);
                runExecutionTimer = null;
            }
        }

        function updateRunExecutionTime() {
            if (!runStartTime) {
                return;
            }

            const now = Date.now();
            const elapsed = now - runStartTime;
            const formattedTime = formatExecutionTime(elapsed);


            const runExecutionTimeElement = document.getElementById('run-execution-time');
            if (runExecutionTimeElement) {
                runExecutionTimeElement.textContent = `â±ï¸ ${formattedTime}`;
                runExecutionTimeElement.style.display = 'inline';
            }
        }

        function showRunExecutionTime() {
            const runExecutionTimeElement = document.getElementById('run-execution-time');
            if (runExecutionTimeElement) {
                runExecutionTimeElement.style.display = 'inline';
            }
        }

        function hideRunExecutionTime() {
            const runExecutionTimeElement = document.getElementById('run-execution-time');
            if (runExecutionTimeElement) {
                runExecutionTimeElement.style.display = 'none';
            }
        }

        function showFinalRunExecutionTime() {
            // Calculate final execution time from start/end times
            const runStartTimeStr = "{{ start_time if start_time else '' }}";
            const runEndTimeStr = "{{ end_time if end_time else '' }}";

            if (runStartTimeStr && runEndTimeStr) {
                // Ensure both times are in proper ISO format
                let startTimeStr = runStartTimeStr;
                let endTimeStr = runEndTimeStr;

                // Add 'Z' to endTime if it doesn't have timezone info
                if (!endTimeStr.includes('Z') && !endTimeStr.includes('+') && !endTimeStr.includes('-', 10)) {
                    endTimeStr += 'Z';
                }

                const start = new Date(startTimeStr);
                const end = new Date(endTimeStr);
                const duration = end - start;

                if (duration > 0) {
                    const formattedTime = formatExecutionTime(duration);
                    const runExecutionTimeElement = document.getElementById('run-execution-time');
                    if (runExecutionTimeElement) {
                        runExecutionTimeElement.textContent = `â±ï¸ ${formattedTime}`;
                        runExecutionTimeElement.style.display = 'inline';
                    }
                }
            }
        }

        function initializeRunExecutionTime() {
            const runStatus = "{{ status }}";
            const runStartTimeStr = "{{ start_time if start_time else '' }}";
            const runEndTimeStr = "{{ end_time if end_time else '' }}";


            // Find the earliest test case start time for more accurate execution time
            let earliestStartTime = null;
            let earliestStartTimeStr = '';

            testMap.forEach((testEntry, testId) => {
                if (testEntry.startTime) {
                    // Test case start times are local time strings - convert to UTC milliseconds for comparison
                    const testStartTime = new Date(testEntry.startTime).getTime();

                    if (!earliestStartTime || testStartTime < earliestStartTime) {
                        earliestStartTime = testStartTime;
                        earliestStartTimeStr = testEntry.startTime;
                    }
                }
            });


            if (runStatus && runStatus.toLowerCase() === 'running') {
                // Use earliest test case start time if available, otherwise use run start time
                const startTimeToUse = earliestStartTimeStr || runStartTimeStr;
                if (startTimeToUse) {
                    runStartTime = new Date(startTimeToUse).getTime();
                    showRunExecutionTime();
                    startRunExecutionTimer();
                }
            } else if (runStartTimeStr && runEndTimeStr) {
                // Run is finished - show final execution time
                showFinalRunExecutionTime();
            }
        }

        function addRunningTest(testId) {
            const { entry, original } = getTestEntryContext(testId);
            if (!entry) return;

            const canonicalId = original ? (original.fullName || testId) : testId;
            const storedData = runningTests.get(canonicalId);
            if (!storedData) {
                const rawStart = (original && original.startTime) || entry.startTime;
                const parsedStart = parseStartTime(rawStart);
                const startTime = parsedStart ?? Date.now();
                runningTests.set(canonicalId, { startTime, testId: canonicalId });

                const execElement = ensureExecutionTimeElement(entry);
                const initialElapsed = Date.now() - startTime;
                const initialFormatted = formatExecutionTime(initialElapsed);
                if (execElement) {
                    execElement.css("display", "inline");
                    execElement.text(`â±ï¸ ${initialFormatted}`);
                }
                if (entry.listViewExecutionTimeElement) {
                    entry.listViewExecutionTimeElement.textContent = `â±ï¸ ${initialFormatted}`;
                }
            }

            startExecutionTimer();
        }

        function removeRunningTest(testId) {
            if (!testId) return;

            if (!runningTests.delete(testId)) {
                // Fall back to removing by stored testId value
                runningTests.forEach((value, key) => {
                    if (value.testId === testId || key === testId) {
                        runningTests.delete(key);
                    }
                });
            }

            if (runningTests.size === 0) {
                stopExecutionTimer();
            }
        }

        // Load user preferences from localStorage
        function loadUserPreferences() {
            const savedViewMode = localStorage.getItem('testRunViewMode');
            const savedSortOrder = localStorage.getItem('testRunSortOrder');
            const savedFilters = localStorage.getItem(STATUS_FILTER_STORAGE_KEY);

            if (savedViewMode === 'list') {
                isListView = true;
            }

            if (savedSortOrder && ['asc', 'desc', 'received'].includes(savedSortOrder)) {
                currentSortOrder = savedSortOrder;
            }

            if (savedFilters) {
                try {
                    const parsedFilters = JSON.parse(savedFilters);
                    STATUS_FILTER_KEYS.forEach(key => {
                        if (typeof parsedFilters[key] === 'boolean') {
                            statusFilters[key] = parsedFilters[key];
                        }
                    });
                } catch (e) {
                    console.warn('Unable to parse test run status filters from storage', e);
                }
            }
        }

        // Save user preferences to localStorage
        function saveUserPreferences() {
            localStorage.setItem('testRunViewMode', isListView ? 'list' : 'tree');
            localStorage.setItem('testRunSortOrder', currentSortOrder);
            localStorage.setItem(STATUS_FILTER_STORAGE_KEY, JSON.stringify(statusFilters));
        }

        // Apply loaded preferences to UI elements
        function applyUserPreferences() {
            // Apply view mode preference
            const button = document.getElementById('view-toggle-btn');
            const listElement = document.getElementById('test-cases-list');
            const expandBtn = document.getElementById('expand-all-btn');
            const collapseBtn = document.getElementById('collapse-all-btn');

            if (isListView) {
                button.textContent = 'Tree View';
                listElement.className = 'list-view';
                expandBtn.style.display = 'none';
                collapseBtn.style.display = 'none';
            } else {
                button.textContent = 'List View';
                listElement.className = 'tree';
                expandBtn.style.display = 'inline-block';
                collapseBtn.style.display = 'inline-block';
            }

            // Apply sort order preference
            const sortSelect = document.getElementById('sort-select');
            if (sortSelect) {
                sortSelect.value = currentSortOrder;
            }

            STATUS_FILTER_KEYS.forEach(key => {
                const checkbox = document.getElementById(`filter-${key}`);
                if (checkbox) {
                    checkbox.checked = !!statusFilters[key];
                }
            });

            // Ensure the correct view is displayed
            ensureCorrectView();
        }

        function getBadgeClass(status) {
            const s = (status || "").toLowerCase();
            switch (s) {
                case "success":
                case "passed":
                case "pass":
                    return "bg-green";
                case "error":
                    return "bg-error";
                case "failed":
                case "fail":
                    return "bg-red";
                case "skipped":
                case "skip":
                    return "bg-skipped";
                case "aborted":
                    return "bg-aborted";
                case "running":
                    return "bg-running";
                default:
                    return "";
            }
        }

        // TestHtmlEntry class for tree building
        class TestHtmlEntry {
            constructor(fullName, traceHtmlFile = null, storageId = null) {
                this.status = '';
                this.fullName = fullName;
                this.traceHtmlFile = traceHtmlFile;
                this.storageId = storageId || null;
                this.children = [];
                this.parent = null;
                this.indicator = null;
                this.isCollapsed = false; // Track collapsed state
                let listItem = $("<li>");
                let ulElement = $("<ul>");
                let textElement;
                let badge = null;

                // Create a row container to align name/time left and badge right
                const row = $("<div>").addClass("tc-row");
                const leftContainer = $("<div>").addClass("tc-main");
                const rightContainer = $("<div>").addClass("tc-right");

                if (traceHtmlFile) {
                    // Only create badge for actual test cases (those with URLs)
                    badge = $("<span>").addClass("badge " + getBadgeClass(this.status)).text(this.status);
                    badge.attr('data-tc-id', fullName); // Store display name for lookup
                    badge.attr('data-storage-id', this.storageId || fullName);

                    // Mark this as an end test case node for CSS targeting
                    listItem.addClass("test-case-node");
                    listItem.attr('data-tc-id', fullName);
                    listItem.attr('data-tc-full-name', fullName); // For classification lookup
                    listItem.attr('data-storage-id', this.storageId || fullName);

                    // Check if files exist on disk
                    const filesExist = {{ files_exist | tojson }};

                    if (filesExist) {
                        textElement = $("<a>").attr("href", traceHtmlFile);
                    } else {
                        // Files have been cleaned up - show disabled text with tooltip
                        textElement = $("<span>").css({
                            "color": "#6c757d",
                            "cursor": "not-allowed"
                        }).attr("title", "Log files have been cleaned up due to retention policy");
                    }

                    // Create execution time element for running tests
                    this.executionTimeElement = $("<span>").addClass("execution-time").css({
                        "font-size": "0.85em",
                        "color": "#6c757d",
                        "display": "inline"
                    });

                    // Create placeholder for new TC indicator (will be shown if TC is new)
                    this.newTcIndicatorContainer = $("<span>").addClass("new-tc-container");

                    // Create placeholder for classification icon (will be populated later)
                    this.classificationContainer = $("<span>").addClass("classification-container");
                } else {
                    // Parent containers - create summary badge that shows when collapsed
                    textElement = $("<span>");
                    badge = $("<span>").addClass("badge summary-badge").css("display", "none");
                    this.summaryBadge = badge; // Store reference for summary badge

                    // Create container for classification icons shown when collapsed
                    this.collapsedClassificationContainer = $("<span>").addClass("collapsed-classification-container").css("display", "none");
                }

                // Build left side: text + new TC indicator
                leftContainer.append(textElement);

                if (this.newTcIndicatorContainer) {
                    leftContainer.append(this.newTcIndicatorContainer);
                }

                // Build right side: badge + execution time + classification icon
                if (badge) {
                    rightContainer.append(badge);
                }

                if (this.executionTimeElement) {
                    rightContainer.append(this.executionTimeElement);
                }

                if (this.classificationContainer) {
                    rightContainer.append(this.classificationContainer);
                }

                // Add collapsed classification container for parent nodes
                if (this.collapsedClassificationContainer) {
                    rightContainer.append(this.collapsedClassificationContainer);
                }

                row.append(leftContainer).append(rightContainer);
                listItem.append(row).append(ulElement);

                this.ulElement = ulElement;
                this.listItem = listItem;
                this.textElement = textElement;
                this.badge = badge;

                // Use setName to handle HTML entity conversion
                this.setName(fullName);
            }

            addChild(child) {
                child.parent = this;
                this.ulElement.append(child.listItem);
                this.children.push(child);

                if (this.indicator == null) {
                    const ulElement = this.ulElement;
                    const indicator = $("<span>").addClass("indicator glyphicon glyphicon-minus");
                    const self = this;

                    indicator.on("click", function () {
                        self.toggleCollapsed();
                    });

                    // Place indicator at the start of the main text container so +/- and name share a line
                    const row = this.listItem.children(".tc-row").first();
                    const main = row.children(".tc-main").first();
                    if (main.length) {
                        main.prepend(indicator);
                    } else {
                        // Fallback: prepend to list item if structure is unexpected
                        this.listItem.prepend(indicator);
                    }
                    this.indicator = indicator;
                }

                // Apply single-child styling if this parent has only one child
                this.updateChildStyling();

                // Check status after adding child (for summary badge)
                this.checkChildrenStatus();
            }

            toggleCollapsed() {
                this.isCollapsed = !this.isCollapsed;

                // Update collapsed state tracking
                if (this.isCollapsed) {
                    collapsedNodes.add(this.fullName);
                } else {
                    collapsedNodes.delete(this.fullName);
                }

                if (this.isCollapsed) {
                    // Collapse this node and all its children
                    this.collapseNode();
                } else {
                    // Expand this node but keep children collapsed if collapse all was used
                    this.expandNode();
                }
            }

            collapseNode() {
                this.ulElement.hide();
                this.indicator.removeClass('glyphicon-minus').addClass('glyphicon-plus');
                this.isCollapsed = true;

                // Show summary badge when collapsed (for parent nodes)
                if (this.summaryBadge) {
                    this.updateSummaryBadge();
                    this.summaryBadge.show();
                }

                // Show collapsed classification icons (for parent nodes)
                if (this.collapsedClassificationContainer) {
                    this.updateCollapsedClassifications();
                    this.collapsedClassificationContainer.show();
                }

                // Recursively collapse all children
                this.children.forEach(child => {
                    if (child.children && child.children.length > 0) {
                        child.collapseNode();
                    }
                });
            }

            expandNode(expandAllChildren = false) {
                this.ulElement.show();
                this.indicator.removeClass('glyphicon-plus').addClass('glyphicon-minus');
                this.isCollapsed = false;

                // Hide summary badge when expanded (for parent nodes)
                if (this.summaryBadge) {
                    this.summaryBadge.hide();
                }

                // Hide collapsed classification icons when expanded (for parent nodes)
                if (this.collapsedClassificationContainer) {
                    this.collapsedClassificationContainer.hide();
                }

                // Expand children if explicitly requested or if collapse all is not active
                if (expandAllChildren || !isCollapseAllActive) {
                    this.children.forEach(child => {
                        if (child.children && child.children.length > 0) {
                            child.expandNode(expandAllChildren);
                        }
                    });
                }
            }

            removeChild(child) {
                var i = 0;
                while (i < this.children.length) {
                    if (this.children[i] === child) {
                        this.children.splice(i, 1);
                        child.listItem.remove();
                        break;
                    } else {
                        ++i;
                    }
                }

                // Update styling after removing a child
                this.updateChildStyling();
            }

            updateChildStyling() {
                // Apply single-child styling to children if parent has only one child
                this.children.forEach(child => {
                    if (this.children.length === 1) {
                        child.listItem.addClass('single-child');
                    } else {
                        child.listItem.removeClass('single-child');
                    }
                });
            }

            setName(name) {
                this.name = name;
                // Convert HTML entities to quotes for display
                let displayName = name.replace(/&quot;/g, '"');
                this.textElement.text(displayName);
            }

            get Status() {
                return this.status;
            }

            set Status(value) {
                if (value != this.status) {
                    // Only update badge if it exists (test cases have badges, parent containers don't)
                    if (this.badge) {
                    this.badge.removeClass("bg-green bg-red bg-skipped bg-aborted bg-running").addClass(getBadgeClass(value)).text(value);
                    if (value.toLowerCase() === "running" && !this.badge.find(".spinner").length) {
                        this.badge.append($("<span>").addClass("spinner"));
                    } else {
                        this.badge.find(".spinner").remove();
                        }
                    }

                    // Handle real-time execution time tracking
                    if (this.traceHtmlFile) { // Only for actual test cases
                        const trackingId = this.originalFullName || this.fullName;
                        if (value.toLowerCase() === "running") {
                            // Ensure execution time element exists and is visible
                            if (!this.executionTimeElement || this.executionTimeElement.length === 0) {
                                this.executionTimeElement = $("<span>").addClass("execution-time").css({
                                    "font-size": "0.85em",
                                    "color": "#6c757d",
                                    "display": "inline"
                                });

                                // Insert into tc-main container
                                const tcMain = this.listItem.find(".tc-main");
                                if (tcMain.length > 0 && this.textElement && this.textElement.length > 0) {
                                    this.textElement.after(this.executionTimeElement);
                                } else if (tcMain.length > 0) {
                                    tcMain.append(this.executionTimeElement);
                                } else {
                                    this.listItem.append(this.executionTimeElement);
                                }
                            } else {
                                // Make sure existing element is visible
                                this.executionTimeElement.css("display", "inline");
                            }

                            addRunningTest(trackingId);
                        } else {
                            removeRunningTest(trackingId);
                            // Show final execution time when test finishes
                            if (this.executionTimeElement) {
                                this.showFinalExecutionTime();
                            }
                            if (this.listViewExecutionTimeElement) {
                                this.showFinalExecutionTime();
                            }
                        }
                    }
                }
                this.status = value;
                if (this.parent) {
                    this.parent.checkChildrenStatus();
                }
            }

            showFinalExecutionTime() {
                // Ensure execution time element exists for finished tests
                if (!this.executionTimeElement || this.executionTimeElement.length === 0) {
                    if (this.traceHtmlFile) {
                        // Only create for actual test cases
                        this.executionTimeElement = $("<span>").addClass("execution-time").css({
                            "font-size": "0.85em",
                            "color": "#6c757d",
                            "display": "inline"
                        });

                        // Insert into tc-main container
                        const tcMain = this.listItem.find(".tc-main");
                        if (tcMain.length > 0 && this.textElement && this.textElement.length > 0) {
                            this.textElement.after(this.executionTimeElement);
                        } else if (tcMain.length > 0) {
                            tcMain.append(this.executionTimeElement);
                        } else {
                            this.listItem.append(this.executionTimeElement);
                        }
                    } else {
                        // Not a test case, can't show execution time
                        return;
                    }
                }

                // Make sure element is visible
                if (this.executionTimeElement) {
                    this.executionTimeElement.css("display", "inline");
                }

                // Prefer explicit executionTime if already computed (e.g. from live updates)
                if (this.executionTime) {
                    const formatted = this.executionTime.startsWith('â±ï¸')
                        ? this.executionTime
                        : `â±ï¸ ${this.executionTime}`;
                    if (this.executionTimeElement) {
                        this.executionTimeElement.text(formatted);
                    }
                    if (this.listViewExecutionTimeElement) {
                        this.listViewExecutionTimeElement.textContent = formatted;
                    }
                    return;
                }

                // Otherwise calculate from start/end times if available
                if (this.startTime && this.endTime) {
                    // Test case start/end times are local time strings - use them as-is
                    const startTimeStr = this.startTime;
                    const endTimeStr = this.endTime;

                    const start = new Date(startTimeStr);
                    const end = new Date(endTimeStr);
                    const duration = end - start;

                    if (duration > 0) {
                        const formattedTime = formatExecutionTimeWithMillis(duration);
                        if (this.executionTimeElement) {
                            this.executionTimeElement.text(`â±ï¸ ${formattedTime}`);
                        }
                        if (this.listViewExecutionTimeElement) {
                            this.listViewExecutionTimeElement.textContent = `â±ï¸ ${formattedTime}`;
                        }
                    }
                }
            }

            // Recursively collect all leaf node statuses from this node's subtree
            getAllLeafStatuses() {
                const statuses = [];

                const collectStatuses = (node) => {
                    node.children.forEach(child => {
                        if (child.traceHtmlFile) {
                            // This is a leaf node (actual test case)
                            if (child.status) {
                                const status = child.status.toLowerCase();
                                // Ignore "not-executed" or null statuses
                                if (status && status !== 'not-executed') {
                                    statuses.push(status);
                                }
                            }
                        } else {
                            // This is a parent node, recurse into its children
                            collectStatuses(child);
                        }
                    });
                };

                collectStatuses(this);
                return statuses;
            }

            getAllLeafStatusCounts() {
                const counts = {
                    running: 0,
                    passed: 0,
                    failed: 0,
                    skipped: 0,
                    aborted: 0,
                    error: 0
                };

                const collectStatuses = (node) => {
                    node.children.forEach(child => {
                        if (child.traceHtmlFile) {
                            // This is a leaf node (actual test case)
                            if (child.status) {
                                const status = child.status.toLowerCase();
                                // Ignore "not-executed" or null statuses
                                if (status && status !== 'not-executed') {
                                    // Normalize status names
                                    if (status === 'running') {
                                        counts.running++;
                                    } else if (status === 'passed' || status === 'pass' || status === 'success') {
                                        counts.passed++;
                                    } else if (status === 'failed' || status === 'fail') {
                                        counts.failed++;
                                    } else if (status === 'skipped' || status === 'skip') {
                                        counts.skipped++;
                                    } else if (status === 'aborted') {
                                        counts.aborted++;
                                    } else if (status === 'error') {
                                        counts.error++;
                                    }
                                }
                            }
                        } else {
                            // This is a parent node, recurse into its children
                            collectStatuses(child);
                        }
                    });
                };

                collectStatuses(this);
                return counts;
            }

            // Get unique classification types from all leaf nodes
            getAllLeafClassifications() {
                const classifications = new Set();

                const collectClassifications = (node) => {
                    node.children.forEach(child => {
                        if (child.traceHtmlFile) {
                            // This is a leaf node (actual test case)
                            // Use originalFullName if available, otherwise fullName
                            // (tree building may shorten fullName for display purposes)
                            const lookupKey = child.originalFullName || child.fullName;
                            const classData = classificationsData[lookupKey];
                            if (classData) {
                                if (classData.is_new) {
                                    classifications.add('new');
                                }
                                if (classData.classification) {
                                    classifications.add(classData.classification);
                                }
                            }
                        } else {
                            // This is a parent node, recurse into its children
                            collectClassifications(child);
                        }
                    });
                };

                collectClassifications(this);
                return classifications;
            }

            // Update collapsed classification icons
            updateCollapsedClassifications() {
                if (!this.collapsedClassificationContainer) return;
                if (typeof Classifications === 'undefined') {
                    return;
                }

                // Clear existing icons
                this.collapsedClassificationContainer.empty();

                // Get unique classifications from all leaf nodes
                const classificationTypes = this.getAllLeafClassifications();

                // Add one icon per classification type (deduplicated)
                classificationTypes.forEach(classType => {
                    if (classType === 'new') {
                        const indicator = Classifications.createNewTcIndicator();
                        this.collapsedClassificationContainer.append(indicator);
                    } else {
                        const icon = Classifications.createClassificationIcon(classType);
                        this.collapsedClassificationContainer.append(icon);
                    }
                });
            }

            checkChildrenStatus() {
                // Recursively get all leaf node statuses from the entire subtree
                const childStatuses = this.getAllLeafStatuses();

                if (childStatuses.length === 0) {
                    // No executed tests
                    this.Status = '';
                    if (this.summaryBadge) {
                        this.summaryBadge.hide();
                    }
                    return;
                }

                // Priority: running > error > failed/aborted > skipped (if all) > passed
                // Check for running first (highest priority)
                if (childStatuses.some(s => s === 'running')) {
                    this.Status = 'Running';
                } else if (childStatuses.some(s => s === 'error')) {
                    this.Status = 'Error';
                } else if (childStatuses.some(s => s === 'aborted')) {
                    // Aborted is treated as a failure category
                    this.Status = 'Aborted';
                } else if (childStatuses.some(s => s === 'failed' || s === 'fail')) {
                    this.Status = 'Failed';
                } else if (childStatuses.every(s => s === 'skipped' || s === 'skip')) {
                    // All are skipped
                    this.Status = 'Skipped';
                } else if (childStatuses.every(s => s === 'passed' || s === 'pass' || s === 'success' || s === 'skipped' || s === 'skip')) {
                    // All executed tests passed (skipped tests are allowed)
                    this.Status = 'Passed';
                } else {
                    // Default to passed if we have some passed tests
                    this.Status = 'Passed';
                }

                // Update summary badge if it exists and node is collapsed
                if (this.summaryBadge && this.isCollapsed) {
                    this.updateSummaryBadge();
                    this.summaryBadge.show();
                }
            }

            updateSummaryBadge() {
                if (!this.summaryBadge || !this.status) {
                    return;
                }

                // Get status counts for tooltip
                const counts = this.getAllLeafStatusCounts();
                const parts = [];
                if (counts.running > 0) parts.push(`${counts.running} running`);
                if (counts.error > 0) parts.push(`${counts.error} error`);
                if (counts.passed > 0) parts.push(`${counts.passed} passed`);
                if (counts.failed > 0) parts.push(`${counts.failed} failed`);
                if (counts.skipped > 0) parts.push(`${counts.skipped} skipped`);
                if (counts.aborted > 0) parts.push(`${counts.aborted} aborted`);
                const tooltip = parts.length > 0 ? parts.join(', ') : 'No tests executed';

                // Update badge class, text, and tooltip
                this.summaryBadge
                    .removeClass("bg-green bg-red bg-skipped bg-aborted bg-running bg-error")
                    .addClass(getBadgeClass(this.status))
                    .text(this.status)
                    .attr("title", tooltip);
            }
        }

        function getParentName(fullName) {
            // Handle bracket notation and quotes - don't split on dots/plus inside square brackets or quotes
            let bracketDepth = 0;
            let inQuotes = false;
            let quoteChar = null;
            let lastSeparatorIndex = -1;

            for (let i = fullName.length - 1; i >= 0; i--) {
                const char = fullName[i];

                if ((char === '"' || char === "'") && bracketDepth === 0) {
                    if (!inQuotes) {
                        inQuotes = true;
                        quoteChar = char;
                    } else if (char === quoteChar) {
                        inQuotes = false;
                        quoteChar = null;
                    }
                } else if (char === ']' && !inQuotes) {
                    bracketDepth++;
                } else if (char === '[' && !inQuotes) {
                    bracketDepth--;
                    if (bracketDepth < 0) bracketDepth = 0; // Safety check
                } else if ((char === '.' || char === '+') && bracketDepth === 0 && !inQuotes) {
                    lastSeparatorIndex = i;
                    break;
                }
            }

            if (lastSeparatorIndex === -1) {
                return ""; // No parent if no separators outside brackets/quotes
            }
            return fullName.substring(0, lastSeparatorIndex);
        }


        // New smart tree building functions
        function getAllPossiblePrefixes(testNames) {
            const prefixes = new Set();

            testNames.forEach(fullName => {
                // Get all possible prefixes for this test name
                let currentName = fullName;
                while (currentName.includes('.')) {
                    const parentName = getParentName(currentName);
                    if (parentName !== "") {
                        prefixes.add(parentName);
                        currentName = parentName;
                    } else {
                        break;
                    }
                }
            });

            return Array.from(prefixes);
        }

        function findOptimalTreeStructure(testNames) {
            const prefixes = getAllPossiblePrefixes(testNames);
            const prefixUsage = new Map();

            // Count how many test cases use each prefix
            prefixes.forEach(prefix => {
                const count = testNames.filter(name => name.startsWith(prefix + '.')).length;
                prefixUsage.set(prefix, count);
            });

            // Only keep prefixes that have multiple children
            const validPrefixes = new Set();
            prefixUsage.forEach((count, prefix) => {
                if (count > 1) {
                    validPrefixes.add(prefix);
                }
            });

            // Build the optimal structure
            const structure = new Map();
            const roots = [];

            testNames.forEach(fullName => {
                // Find the longest valid prefix for this test
                let bestPrefix = "";
                let currentName = fullName;

                while (currentName.includes('.')) {
                    const parentName = getParentName(currentName);
                    if (parentName !== "" && validPrefixes.has(parentName)) {
                        bestPrefix = parentName;
                        break;
                    }
                    currentName = parentName;
                }

                if (bestPrefix === "") {
                    // This is a root-level test
                    roots.push(fullName);
                } else {
                    // This belongs to a parent
                    if (!structure.has(bestPrefix)) {
                        structure.set(bestPrefix, []);
                    }
                    structure.get(bestPrefix).push(fullName);
                }
            });

            return { roots, structure };
        }

        function buildSmartTree(testData) {

            // Check if we should keep the live indicator based on running tests
            let shouldKeepLiveIndicator = false;
            testData.forEach(test => {
                if (test.status && test.status.toLowerCase() === 'running') {
                    shouldKeepLiveIndicator = true;
                }
            });

            // Preserve live indicator before clearing only if we should keep it
            const liveIndicator = document.querySelector('.live-indicator');
            const liveIndicatorHTML = (shouldKeepLiveIndicator && liveIndicator) ? liveIndicator.outerHTML : null;

            // Clear existing tree
            testMap.clear();
            root = null;
            $('#test-cases-list').empty();

            // Get all test names
            const testNames = testData.map(test => test.name);

            // Find optimal tree structure
            const { roots, structure } = findOptimalTreeStructure(testNames);


            // Create all test entries first
            testData.forEach(test => {
                const testEntry = new TestHtmlEntry(test.name, test.url, test.storageId);
                testEntry.Status = test.status;
                testMap.set(test.name, testEntry);
            });

            // Build the tree structure
            const rootEntries = [];

            // Handle root-level tests
            roots.forEach(testName => {
                const testEntry = testMap.get(testName);
                if (testEntry) {
                    rootEntries.push(testEntry);
                }
            });

            // Handle grouped tests
            structure.forEach((children, parentName) => {
                // Create parent entry
                const parentEntry = new TestHtmlEntry(parentName);
                testMap.set(parentName, parentEntry);

                // Add children to parent
                children.forEach(childName => {
                    const childEntry = testMap.get(childName);
                    if (childEntry) {
                        // Set display name to just the part after the parent
                        const displayName = childName.slice(parentName.length + 1);
                        childEntry.setName(displayName);
                        parentEntry.addChild(childEntry);
                    }
                });

                rootEntries.push(parentEntry);
            });

            // Set up the root structure
            if (rootEntries.length === 1) {
                root = rootEntries[0];
            } else if (rootEntries.length > 1) {
                // Create a virtual root if we have multiple top-level entries
                const virtualRoot = new TestHtmlEntry("Test Cases");
                rootEntries.forEach(entry => {
                    virtualRoot.addChild(entry);
                });
                root = virtualRoot;
            }

            // Add root to DOM
            if (root) {
                $('#test-cases-list').append(root.listItem);
                updateTreeStyling(root);

                // Reset collapse all state when tree is rebuilt
                isCollapseAllActive = false;
            }

            // Restore live indicator if it existed
            if (liveIndicatorHTML) {
                $('#test-cases-list').append(liveIndicatorHTML);
        }
        }

        function updateTree(testData) {
            // Clear existing test map and rebuild with compact tree
            testMap.clear();

            // Add all test cases to the test map
            testData.forEach(test => {
                const testEntry = new TestHtmlEntry(test.name, test.url, test.storageId);
                testEntry.Status = test.status || 'running';

                // Store start and end times for execution time calculation
                if (test.start_time) {
                    testEntry.startTime = test.start_time;
                }
                if (test.end_time) {
                    testEntry.endTime = test.end_time;
                }

                // Precompute executionTime for finished tests so both tree and list views
                // can display durations even before any live updates happen.
                if (testEntry.startTime && testEntry.endTime && testEntry.Status.toLowerCase() !== 'running') {
                    const start = new Date(testEntry.startTime);
                    const end = new Date(testEntry.endTime);
                    const duration = end - start;
                    if (duration > 0) {
                        testEntry.executionTime = formatExecutionTimeWithMillis(duration);
                    }
                }

                testMap.set(test.name, testEntry);
            });

            // Build compact tree
            rebuildCompactTree();
        }

        function updateTreeStyling(entry) {
            if (!entry) return;

            // Update styling for this entry's children
            entry.updateChildStyling();

            // Recursively update styling for all children
            entry.children.forEach(child => {
                updateTreeStyling(child);
            });
        }

        // Add live indicator to test tree
        function addLiveIndicator() {
            const testList = document.getElementById('test-cases-list');
            if (testList && !testList.querySelector('.live-indicator')) {
                const liveItem = document.createElement('li');
                liveItem.className = 'live-indicator';
                liveItem.style.cssText = 'text-align: left; color: #666; font-style: italic; background: rgba(102, 126, 234, 0.05); border: none; padding: 8px 15px; margin: 5px 0; border-radius: 6px;';
                liveItem.innerHTML = '<span class="dots"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>';
                testList.appendChild(liveItem);
            }
        }

        // Remove live indicator from test tree
        function removeLiveIndicator() {
            const liveIndicator = document.querySelector('.live-indicator');
            if (liveIndicator) {
                liveIndicator.remove();
            }
        }


        function addOrUpdateTestCase(tc_full_name, tc_meta, forceRunning = false) {
            let testEntry = null;
            let isNewTest = false;
            if (testMap.has(tc_full_name)) {
                testEntry = testMap.get(tc_full_name);
            } else {
                const tc_id = tc_meta.tc_id;
                if (!tc_id) {
                    console.warn('Missing tc_id for entry', tc_full_name, tc_meta);
                    return;
                }
                const traceUrl = `${LOG_URL_BASE}${encodeURIComponent(tc_id)}.html`;
                testEntry = new TestHtmlEntry(tc_full_name, traceUrl, tc_id);
                testMap.set(tc_full_name, testEntry);
                isNewTest = true;
            }

            // For test_case_started events, force status to "running"
            // For new test cases from test_case_finished, show as "running" briefly then final result
            let status;
            if (forceRunning) {
                status = "running";
            } else if (isNewTest) {
                // New test case from test_case_finished - show as running briefly
                status = "running";
                // Set final status after a brief delay
                setTimeout(() => {
                    testEntry.Status = tc_meta.status || "running";
                    // Just update the badge, don't rebuild the entire tree
                    updateTestCaseBadge(testEntry);
                }, 1000);
            } else {
                status = tc_meta.status || "running";
            }

            testEntry.Status = status;

            // Store start and end times for final execution time calculation
            if (tc_meta.start_time) {
                testEntry.startTime = tc_meta.start_time;
            }
            if (tc_meta.end_time) {
                testEntry.endTime = tc_meta.end_time;
            }

            // Calculate execution time if test case has finished
            if (tc_meta.start_time && tc_meta.end_time && status.toLowerCase() !== 'running') {
                const startTime = new Date(tc_meta.start_time);
                const endTime = new Date(tc_meta.end_time);
                const duration = endTime - startTime;

                if (duration > 0) {
                    testEntry.executionTime = formatExecutionTimeWithMillis(duration);
                }
            }

            if (isNewTest) {
                // Track the order test cases are received
                if (!testCaseOrder.includes(tc_full_name)) {
                    testCaseOrder.push(tc_full_name);
                }

                // Refresh classifications for new test cases (they may be marked as "new")
                if (runConfig.serverMode && typeof Classifications !== 'undefined') {
                    // Debounce classification refresh to avoid too many requests
                    if (window._classificationRefreshTimeout) {
                        clearTimeout(window._classificationRefreshTimeout);
                    }
                    window._classificationRefreshTimeout = setTimeout(() => {
                        loadAndApplyClassifications();
                    }, 500);
                }

                // New test case - queue a debounced rebuild
                scheduleViewRebuild();
            } else {
                // Existing test case - just update the badge, no rebuild needed
                updateTestCaseBadge(testEntry);

                // Also update list view item if in list view mode
                if (isListView) {
                    updateListViewItem(testEntry);
                }
            }
        }

        // Schedule a debounced view rebuild for new test cases
        function scheduleViewRebuild() {
            pendingViewRebuild = true;

            if (viewRebuildDebounceTimer) {
                clearTimeout(viewRebuildDebounceTimer);
            }

            viewRebuildDebounceTimer = setTimeout(() => {
                if (pendingViewRebuild) {
                    pendingViewRebuild = false;
                    rebuildCurrentView();
                }
            }, VIEW_REBUILD_DEBOUNCE_MS);
        }

        // Update a list view item without rebuilding the entire list
        function updateListViewItem(testEntry) {
            if (!testEntry || !isListView) return;

            const listElement = document.getElementById('test-cases-list');
            if (!listElement) return;

            // Find the existing list item by fullName
            const existingItem = listElement.querySelector(`li[data-tc-full-name="${CSS.escape(testEntry.fullName)}"]`);
            if (!existingItem) return;

            // Update the badge
            const badge = existingItem.querySelector('.badge');
            if (badge) {
                const badgeClass = getBadgeClass(testEntry.Status);
                const hadHistory = badge.classList.contains('status-badge-with-history');
                badge.className = 'badge ' + badgeClass + (hadHistory ? ' status-badge-with-history' : '');
                badge.textContent = testEntry.Status;

                // Add/remove spinner for running status
                const existingSpinner = badge.querySelector('.spinner');
                if (testEntry.Status && testEntry.Status.toLowerCase() === 'running') {
                    if (!existingSpinner) {
                        const spinner = document.createElement('span');
                        spinner.className = 'spinner';
                        badge.appendChild(document.createTextNode(' '));
                        badge.appendChild(spinner);
                    }
                } else if (existingSpinner) {
                    // Remove spinner and trailing space
                    existingSpinner.remove();
                }
            }

            // Update execution time if available
            const timeElement = existingItem.querySelector('.execution-time');
            if (timeElement && testEntry.executionTime) {
                timeElement.textContent = `â±ï¸ ${testEntry.executionTime}`;
            }
        }

        function updateTestCaseBadge(testEntry) {
            // Update the badge for an existing test case without rebuilding the tree
            if (testEntry.badge) {
                const badgeClass = getBadgeClass(testEntry.Status);
                const badgeEl = testEntry.badge[0]; // Get DOM element from jQuery object
                const hadHistory = badgeEl && badgeEl.classList.contains('status-badge-with-history');
                const tcId = testEntry.fullName;
                const storageId = testEntry.storageId || tcId;

                // Update badge class and text - preserve status-badge-with-history if it exists
                const newClass = 'badge ' + badgeClass + (hadHistory ? ' status-badge-with-history' : '');
                testEntry.badge.attr('class', newClass)
                              .attr('data-tc-id', tcId)
                              .text(testEntry.Status);

                // Ensure data-tc-id is set on DOM element and list item
                badgeEl.setAttribute('data-tc-id', tcId);
                badgeEl.setAttribute('data-storage-id', storageId);
                if (testEntry.listItem && testEntry.listItem.length > 0) {
                    testEntry.listItem[0].setAttribute('data-tc-id', tcId);
                    testEntry.listItem[0].setAttribute('data-storage-id', storageId);
                }

                // Add/remove spinner for running status
                if (testEntry.Status && testEntry.Status.toLowerCase() === 'running') {
                    if (!testEntry.badge.find('.spinner').length) {
                        testEntry.badge.append(' <span class="spinner"></span>');
                    }
                } else {
                    testEntry.badge.find('.spinner').remove();
                }

                // Always reattach hover handler if Classifications is available
                // This ensures handlers work even if badge was updated before initial setup
                if (typeof Classifications !== 'undefined' && Classifications.setupBadgeHistoryHoverAsync && runConfig && runConfig.runId) {
                    // Ensure the badge has the class and data attribute
                    badgeEl.classList.add('status-badge-with-history');
                    badgeEl.setAttribute('data-tc-id', tcId);

                    // Reattach handlers (function handles removing old ones)
                    Classifications.setupBadgeHistoryHoverAsync(badgeEl, storageId, runConfig.groupHash || null, runConfig.runId, tcId);
                }
            }

            // Update execution time in tree view if available
            if (testEntry.executionTimeElement && testEntry.executionTime) {
                testEntry.executionTimeElement.text(`â±ï¸ ${testEntry.executionTime}`);
            }
        }

        function addTestCaseToTree(newTestEntry) {
            // Add a new test case to the existing tree structure
            const fullName = newTestEntry.fullName;

            // Find where this test case should be placed in the tree
            const parentName = getParentName(fullName);

            if (parentName === "") {
                // This is a root-level test case
                addRootTestCase(newTestEntry);
            } else {
                // This belongs to a parent - find or create the parent
                addChildTestCase(newTestEntry, parentName);
            }

            // Update tree styling after adding
            updateTreeStyling(root);
        }

        function addRootTestCase(testEntry) {
            // Add a root-level test case
            if (!root) {
                // First test case - create root
                root = testEntry;
                $('#test-cases-list').append(testEntry.listItem);
            } else if (root.fullName === "Test Cases") {
                // Virtual root exists - add as child
                root.addChild(testEntry);
            } else {
                // Convert single root to virtual root
                const virtualRoot = new TestHtmlEntry("Test Cases");
                virtualRoot.addChild(root);
                virtualRoot.addChild(testEntry);
                root = virtualRoot;

                // Replace the DOM element
                $('#test-cases-list').empty();
                $('#test-cases-list').append(root.listItem);
            }
        }

        function shouldCreateParentNode(parentName) {
            // Always create parent nodes initially - we'll flatten them later if needed
            // This prevents the issue where test cases are flattened too early
            return true;
        }

        function printTreeStructure() {
            // Debug function for tree structure analysis
            function printEntry(entry, depth = 0) {
                const indent = '  '.repeat(depth);
                const type = entry.traceHtmlFile ? 'TEST' : 'PARENT';
                entry.children.forEach(child => printEntry(child, depth + 1));
            }

            if (root) {
                printEntry(root);
            }
        }

        // NEW COMPACT TREE LOGIC

        function getPathSegments(path) {
            // Split path by dots and plus signs, but ignore them inside brackets or quotes
            // This handles nested classes (Parent+Child) and parameterized tests with quoted strings
            const segments = [];
            let currentSegment = '';
            let bracketDepth = 0;
            let inQuotes = false;
            let quoteChar = null;

            for (let i = 0; i < path.length; i++) {
                const char = path[i];

                // Handle quote characters
                if ((char === '"' || char === "'") && bracketDepth === 0) {
                    if (!inQuotes) {
                        inQuotes = true;
                        quoteChar = char;
                    } else if (char === quoteChar) {
                        inQuotes = false;
                        quoteChar = null;
                    }
                    currentSegment += char;
                } else if (char === '[' && !inQuotes) {
                    bracketDepth++;
                    currentSegment += char;
                } else if (char === ']' && !inQuotes) {
                    bracketDepth--;
                    currentSegment += char;
                } else if ((char === '.' || char === '+') && bracketDepth === 0 && !inQuotes) {
                    if (currentSegment) {
                        segments.push(currentSegment);
                        currentSegment = '';
                    }
                } else {
                    currentSegment += char;
                }
            }

            if (currentSegment) {
                segments.push(currentSegment);
            }

            return segments;
        }

        function shouldDisplayByStatus(status) {
            if (!status) return true;
            const normalized = status.toLowerCase();
            if (['passed', 'pass', 'success'].includes(normalized)) {
                return !!statusFilters.passed;
            }
            if (['failed', 'fail', 'failure'].includes(normalized)) {
                return !!statusFilters.failed;
            }
            if (['skipped', 'skip', 'ignored'].includes(normalized)) {
                return !!statusFilters.skipped;
            }
            // Error filter also includes aborted TCs
            if (['error', 'aborted'].includes(normalized)) {
                return !!statusFilters.error;
            }
            return true;
        }

        function getFilteredTestEntries() {
            return Array.from(testMap.values())
                .filter(tc => tc.traceHtmlFile)
                .filter(tc => shouldDisplayByStatus(tc.Status));
        }

        function renderEmptyState(container, message) {
            if (!container) return;
            const isList = container.tagName && container.tagName.toLowerCase() === 'ul';
            const node = document.createElement(isList ? 'li' : 'div');
            node.className = 'empty-state';
            node.innerHTML = '<i class="glyphicon glyphicon-search"></i><p>' + message + '</p>';
            container.appendChild(node);
        }

        function rebuildCurrentView() {
            if (isListView) {
                buildListView();
            } else {
                rebuildCompactTree();
                // rebuildCompactTree calls setupBadgeHoverHandlers internally
            }

            // Reapply classifications after view is rebuilt
            if (classificationsData && Object.keys(classificationsData).length > 0 && isListView) {
                applyClassificationsToTree();
                setTimeout(() => applyClassificationsToTree(), 100);
            }
        }

        // Align status badges in tree/list view so they form a table-like column
        function alignStatusBadges() {
            const container = document.getElementById('test-cases-list');
            if (!container) return;

            const containerRect = container.getBoundingClientRect();
            const containerLeft = containerRect.left;
            const containerWidth = containerRect.width;
            const computedStyle = getComputedStyle(container);
            const rightWidthRaw = computedStyle.getPropertyValue('--tc-right-width');
            const parsedRightWidth = parseInt(rightWidthRaw, 10);

            // Find all tc-main elements (test case name containers)
            const tcMainElements = container.querySelectorAll('.tc-main');

            // Calculate the maximum right edge position (relative to container)
            let maxRightEdge = 0;
            tcMainElements.forEach(el => {
                const rect = el.getBoundingClientRect();
                const rightEdge = rect.right - containerLeft;
                if (rightEdge > maxRightEdge) {
                    maxRightEdge = rightEdge;
                }
            });

            // For list view, check the left side text spans/links
            const listTextSpans = container.querySelectorAll('.list-view .list-left .list-left-text');
            listTextSpans.forEach(el => {
                const rect = el.getBoundingClientRect();
                const naturalWidth = Math.max(el.scrollWidth || 0, rect.width);
                const rightEdge = (rect.left - containerLeft) + naturalWidth;
                if (rightEdge > maxRightEdge) {
                    maxRightEdge = rightEdge;
                }
            });

            // Determine the max width needed for the right column (badge/time/classifications)
            let maxRightWidth = 0;
            const rightElements = container.querySelectorAll('.tc-right, .list-view-right');
            rightElements.forEach(el => {
                const rect = el.getBoundingClientRect();
                if (rect.width > maxRightWidth) {
                    maxRightWidth = rect.width;
                }
            });

            const rightMinWidth = Math.max(
                Number.isFinite(parsedRightWidth) ? parsedRightWidth : 0,
                maxRightWidth,
                160
            );
            container.style.setProperty('--tc-right-width', rightMinWidth + 'px');

            // Add some padding
            const padding = container.classList.contains('list-view') ? 12 : 20;
            let statusLeft = Math.max(maxRightEdge + padding, 100);

            // Clamp so the right column stays inside the container
            if (containerWidth > 0) {
                const maxLeft = Math.max(containerWidth - rightMinWidth - 8, 0);
                statusLeft = Math.min(statusLeft, maxLeft);
            }

            // Set the CSS variable on the container
            container.style.setProperty('--tc-status-left', statusLeft + 'px');
        }

        // Setup hover handlers for all badges in tree view
        function setupBadgeHoverHandlers() {
            const testCasesList = document.getElementById('test-cases-list');
            if (!testCasesList || typeof Classifications === 'undefined') {
                return;
            }

            if (!runConfig || !runConfig.runId) {
                return;
            }

            // Use testMap to iterate (like list view), then find corresponding badge in DOM
            const attemptSetup = () => {
                if (!testMap || testMap.size === 0) return;

                // Track which nodes we've already processed to avoid duplicates
                const processedNodes = new Set();

                testMap.forEach((testEntry, fullName) => {
                    if (!testEntry.traceHtmlFile) return; // Skip parent containers

                    // Use fullName from testMap - this is the EXACT same ID that list view uses
                    const tcId = fullName;
                    const storageId = testEntry.storageId || tcId;

                    // Find the corresponding DOM node
                    let node = null;

                    // First try: find by data-tc-full-name (most reliable after updateTreeDataAttributes)
                    const nodesByFullName = testCasesList.querySelectorAll('.test-case-node[data-tc-full-name="' + CSS.escape(tcId) + '"]');
                    for (let n of nodesByFullName) {
                        if (!processedNodes.has(n)) {
                            node = n;
                            break;
                        }
                    }

                    // Second try: find by data-tc-id
                    if (!node) {
                        const nodesById = testCasesList.querySelectorAll('.test-case-node[data-tc-id="' + CSS.escape(tcId) + '"]');
                        for (let n of nodesById) {
                            if (!processedNodes.has(n)) {
                                node = n;
                                break;
                            }
                        }
                    }

                    // Third try: find by matching link href with storageId
                    if (!node) {
                        const links = testCasesList.querySelectorAll('.test-case-node a');
                        for (let link of links) {
                            if (link.href) {
                                // Extract the log filename from link
                                const linkMatch = link.href.match(/log\/([^/]+)\.html/);
                                if (linkMatch) {
                                    const linkId = decodeURIComponent(linkMatch[1]);
                                    // Match with storageId (tc_id in URL)
                                    if (linkId === storageId) {
                                        const candidateNode = link.closest('.test-case-node');
                                        // Only use if not already processed
                                        if (candidateNode && !processedNodes.has(candidateNode)) {
                                            node = candidateNode;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (!node) return;

                    // Skip if already processed
                    if (processedNodes.has(node)) return;
                    processedNodes.add(node);

                    const badgeEl = node.querySelector('.badge');
                    if (!badgeEl) return;

                    // Ensure data attributes are set correctly
                    badgeEl.setAttribute('data-tc-id', tcId);
                    badgeEl.setAttribute('data-storage-id', storageId);
                    node.setAttribute('data-tc-id', tcId);
                    node.setAttribute('data-tc-full-name', tcId);
                    node.setAttribute('data-storage-id', storageId);

                    // Attach handlers (function handles removing old ones)
                    Classifications.setupBadgeHistoryHoverAsync(badgeEl, storageId, runConfig.groupHash || null, runConfig.runId, tcId);
                });
            };

            // Try immediately and with delays
            attemptSetup();
            setTimeout(attemptSetup, 100);
            setTimeout(attemptSetup, 300);
            setTimeout(attemptSetup, 600);
        }

        // Update data-tc-full-name attributes on all tree nodes to match their actual fullName
        // This is needed because buildCompactTree creates temp entries with shortened names
        // and restores original fullNames afterwards
        function updateTreeDataAttributes(node) {
            if (!node) return;

            // Update data attribute for actual test cases (those with traceHtmlFile)
            if (node.traceHtmlFile && node.listItem && node.listItem.length > 0) {
                node.listItem.attr('data-tc-full-name', node.fullName);
                node.listItem.attr('data-tc-id', node.fullName);
                if (node.storageId) {
                    node.listItem.attr('data-storage-id', node.storageId);
                }
            }

            // Recursively update children
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => updateTreeDataAttributes(child));
            }
        }

        function rebuildCompactTree() {

            // Save collapsed state before clearing tree
            if (root) {
                saveCollapsedState(root);
            }

            // Clear existing tree
            const listElement = $('#test-cases-list');
            listElement.empty();
            root = null;

            if (isListView) {
                buildListView();
                return;
            }

            const testCases = getFilteredTestEntries();

            if (testCases.length === 0) {
                renderEmptyState(listElement[0], 'No test cases match the selected filters.');
                return;
            }

            // Sort test cases before building tree
            const sortedTestCases = sortTestCases(testCases);

            // Build the most compact tree structure
            const treeRoot = buildCompactTree(sortedTestCases);

            // Add to DOM
            listElement.append(treeRoot.listItem);
            root = treeRoot;

            // Update data attributes on all tree nodes (needed for classification lookup)
            updateTreeDataAttributes(root);

            // Restore collapsed state after rebuilding
            restoreCollapsedState(root);

            // Reattach execution time elements for all test cases (they may have been lost during tree rebuild)
            reattachExecutionTimeElements(root);

            // Re-establish execution time tracking for running tests
            reestablishExecutionTimeTracking();

            // Calculate and display execution time for finished test cases
            calculatePreloadedExecutionTimes();

            // Apply classifications immediately after tree is built
            // Also setup badge hover handlers
            if (classificationsData && Object.keys(classificationsData).length > 0) {
                // Use requestAnimationFrame to ensure DOM is fully updated
                requestAnimationFrame(() => {
                    applyClassificationsToTree();
                });
            }

            // Always setup badge hover handlers after tree rebuild (even without classifications)
            setupBadgeHoverHandlers();

            // Align status badges after tree is fully rendered
            requestAnimationFrame(() => {
                alignStatusBadges();
            });
        }

        // Recursively save collapsed state of all nodes
        function saveCollapsedState(node) {
            if (!node) return;

            // Only save state for parent nodes (those without traceHtmlFile)
            if (!node.traceHtmlFile && node.isCollapsed) {
                collapsedNodes.add(node.fullName);
            }

            // Recursively save children
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    saveCollapsedState(child);
                });
            }
        }

        // Recursively restore collapsed state of all nodes
        function restoreCollapsedState(node) {
            if (!node) return;

            // Only restore state for parent nodes (those without traceHtmlFile)
            if (!node.traceHtmlFile && collapsedNodes.has(node.fullName)) {
                node.isCollapsed = true;
                // Manually collapse without recursively collapsing children
                node.ulElement.hide();
                if (node.indicator) {
                    node.indicator.removeClass('glyphicon-minus').addClass('glyphicon-plus');
                }
                // Show summary badge when collapsed (for parent nodes)
                if (node.summaryBadge) {
                    node.updateSummaryBadge();
                    node.summaryBadge.show();
                }
            }

            // Recursively restore children (preserve their individual states)
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    restoreCollapsedState(child);
                });
            }
        }

        // Recursively reattach execution time elements that may have been lost during tree rebuild
        function reattachExecutionTimeElements(node) {
            if (!node) return;

            // For actual test cases, ensure execution time element is properly attached
            if (node.traceHtmlFile) {
                // Check if we need to create or reattach execution time element
                let needsElement = false;
                let shouldCreate = false;

                // Determine if we need an execution time element
                if (node.startTime || node.executionTime || (node.Status && node.Status.toLowerCase() === 'running')) {
                    needsElement = true;
                }

                if (needsElement) {
                    // Check if element already exists and is in DOM
                    if (node.executionTimeElement && node.executionTimeElement.length > 0) {
                        if (!node.executionTimeElement.parent().length) {
                            // Element exists but is orphaned - reattach it
                            const tcMain = node.listItem.find(".tc-main");
                            if (tcMain.length > 0 && node.textElement && node.textElement.length > 0) {
                                node.textElement.after(node.executionTimeElement);
                            } else if (tcMain.length > 0) {
                                tcMain.append(node.executionTimeElement);
                            } else {
                                node.listItem.append(node.executionTimeElement);
                            }
                        }
                        // Element is already attached, nothing to do
                    } else {
                        // Element doesn't exist - try to get from original entry first
                        let executionTimeElement = null;

                        if (node.originalEntry && node.originalEntry.executionTimeElement && node.originalEntry.executionTimeElement.length > 0) {
                            // Check if original element is still in DOM
                            if (node.originalEntry.executionTimeElement.parent().length) {
                                // Original element is still attached - clone it
                                executionTimeElement = node.originalEntry.executionTimeElement.clone();
                            } else {
                                // Original element is orphaned - reuse it
                                executionTimeElement = node.originalEntry.executionTimeElement;
                            }
                        }

                        // If we still don't have an element, create a new one
                        if (!executionTimeElement || executionTimeElement.length === 0) {
                            executionTimeElement = $("<span>").addClass("execution-time").css({
                                "font-size": "0.85em",
                                "color": "#6c757d",
                                "display": "inline"
                            });
                        }

                        // Attach the element
                        node.executionTimeElement = executionTimeElement;
                        const tcMain = node.listItem.find(".tc-main");
                        if (tcMain.length > 0 && node.textElement && node.textElement.length > 0) {
                            node.textElement.after(node.executionTimeElement);
                        } else if (tcMain.length > 0) {
                            tcMain.append(node.executionTimeElement);
                        } else {
                            node.listItem.append(node.executionTimeElement);
                        }

                        // If test is finished, show final execution time
                        if (node.executionTime && node.Status && node.Status.toLowerCase() !== 'running') {
                            node.executionTimeElement.text(`â±ï¸ ${node.executionTime}`);
                        }
                    }
                }
            }

            // Recursively process children
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    reattachExecutionTimeElements(child);
                });
            }
        }

        // Recursively find all running test cases in the tree structure
        function findRunningTestsInTree(node, runningTestEntries = []) {
            if (!node) return runningTestEntries;

            // Check if this is a running test case (has traceHtmlFile and is running)
            if (node.traceHtmlFile && node.Status && node.Status.toLowerCase() === 'running') {
                runningTestEntries.push(node);
            }

            // Recursively check children
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    findRunningTestsInTree(child, runningTestEntries);
                });
            }

            return runningTestEntries;
        }

        function reestablishExecutionTimeTracking() {
            const runningIds = new Set();

            if (root) {
                const treeRunning = [];
                findRunningTestsInTree(root, treeRunning);
                treeRunning.forEach(entry => {
                    const id = entry.originalFullName || entry.fullName;
                    if (id) runningIds.add(id);
                });
            }

            testMap.forEach((entry, key) => {
                if (entry.Status && entry.Status.toLowerCase() === 'running' && entry.traceHtmlFile) {
                    const id = entry.fullName || key;
                    if (id) runningIds.add(id);
                }
            });

            // Ensure timers exist for all running tests
            runningIds.forEach(id => {
                const existing = runningTests.get(id);
                if (!existing) {
                    const { entry, original } = getTestEntryContext(id);
                    if (!entry) return;
                    const rawStart = (original && original.startTime) || entry.startTime;
                    const parsedStart = parseStartTime(rawStart);
                    runningTests.set(id, { startTime: parsedStart ?? Date.now(), testId: id });
                }
            });

            // Remap any timers stored under legacy keys to use the canonical id
            const remapQueue = [];
            runningTests.forEach((value, key) => {
                const canonicalId = value.testId || key;
                if (canonicalId && canonicalId !== key) {
                    remapQueue.push([key, canonicalId, value]);
                }
            });
            remapQueue.forEach(([oldKey, newKey, value]) => {
                runningTests.set(newKey, { startTime: value.startTime, testId: newKey });
                if (oldKey !== newKey) {
                    runningTests.delete(oldKey);
                }
            });

            // Remove timers for tests that are no longer running
            runningTests.forEach((value, key) => {
                if (!runningIds.has(key)) {
                    runningTests.delete(key);
                }
            });

            if (runningTests.size > 0) {
                startExecutionTimer();
            } else {
                stopExecutionTimer();
            }
        }

        function ensureCorrectView() {
            // Ensure the correct view is displayed based on user preference
            if (isListView) {
                buildListView();
            } else {
                rebuildCompactTree();
            }
        }

        function applyExecutionTimesToTree(entry) {
            if (!entry) return;

            // Only apply to real test cases (nodes with traceHtmlFile) that are not running
            if (entry.traceHtmlFile && entry.Status && entry.Status.toLowerCase() !== 'running') {
                if (typeof entry.showFinalExecutionTime === 'function') {
                    entry.showFinalExecutionTime();
                }
            }

            if (entry.children && entry.children.length > 0) {
                entry.children.forEach(child => applyExecutionTimesToTree(child));
            }
        }

        function calculatePreloadedExecutionTimes() {
            // Walk the actual tree structure so grouped/virtual nodes also get correct timings
            if (root) {
                applyExecutionTimesToTree(root);
            }
        }

        // Recursively restore originalFullName to fullName for all nodes in a tree
        function restoreOriginalFullNames(node) {
            if (!node) return;

            // Restore this node's fullName if originalFullName exists
            if (node.originalFullName) {
                node.fullName = node.originalFullName;
                // Update data attribute to match restored fullName
                if (node.listItem && node.listItem.length > 0) {
                    node.listItem.attr('data-tc-full-name', node.fullName);
                }
                // Keep originalFullName for classification lookups (don't delete it)
            }

            // Recursively restore children
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => restoreOriginalFullNames(child));
            }
        }

        function buildCompactTree(testCases) {
            if (testCases.length === 0) return null;
            if (testCases.length === 1) {
                // Single test case - return as-is
                const tc = testCases[0];
                tc.setName(tc.fullName);
                return tc;
            }

            // First, group by first-level prefix
            const groups = new Map();
            testCases.forEach(tc => {
                const segments = getPathSegments(tc.fullName);
                if (segments.length === 0) return;

                const firstSegment = segments[0];
                if (!groups.has(firstSegment)) {
                    groups.set(firstSegment, []);
                }
                groups.get(firstSegment).push(tc);
            });

            // If all test cases share the same first-level prefix, build a tree
            if (groups.size === 1) {
                const firstPrefix = Array.from(groups.keys())[0];
                const groupTests = groups.get(firstPrefix);

                // Remove the common first-level prefix and build tree recursively
                const testsWithoutPrefix = [];
                groupTests.forEach(tc => {
                    const segments = getPathSegments(tc.fullName);
                    if (segments.length > 1) {
                        // Remove first segment and rejoin
                        const remaining = segments.slice(1).join('.');
                        testsWithoutPrefix.push({ fullName: remaining, original: tc });
                    } else {
                        // Single segment - this becomes a direct child
                        testsWithoutPrefix.push({ fullName: segments[0], original: tc });
                    }
                });

                // Check if all remaining tests are single segments (direct children)
                const allSingleSegments = testsWithoutPrefix.every(item => !item.fullName.includes('.'));
                if (allSingleSegments) {
                    // All are single segments - create parent with direct children
                    const parent = new TestHtmlEntry(firstPrefix);
                    parent.setName(firstPrefix);
                    testsWithoutPrefix.forEach(item => {
                        const originalTc = item.original;
                        if (!originalTc) return;
                        // Display only the last segment under this parent
                        const segments = getPathSegments(originalTc.fullName);
                        const displayName = segments[segments.length - 1];
                        originalTc.setName(displayName);
                        parent.addChild(originalTc); // Reuse existing entry so timing info is preserved
                    });
                    return parent;
                }

                const subtree = buildCompactTree(testsWithoutPrefix.map(item => {
                    const name = item.fullName;
                    const originalTc = item.original;

                    // Create new TestHtmlEntry for intermediate / virtual nodes,
                    // but always preserve timing/status on leaves.
                    const tempTc = new TestHtmlEntry(name, originalTc ? originalTc.traceHtmlFile : null, originalTc ? originalTc.storageId : null);
                    tempTc.fullName = name; // Use the shortened name for recursive call

                    if (originalTc) {
                        tempTc.Status = originalTc.Status;
                        // Preserve the TRUE original fullName through recursion levels
                        // If originalTc already has an originalFullName, use that; otherwise use its fullName
                        tempTc.originalFullName = originalTc.originalFullName || originalTc.fullName;
                        // Propagate timing information so execution time works in tree view
                        tempTc.startTime = originalTc.startTime;
                        tempTc.endTime = originalTc.endTime;
                        tempTc.executionTime = originalTc.executionTime;
                        // Store reference to original entry so we can find it later
                        tempTc.originalEntry = originalTc;

                        // If original entry has an execution time element, try to reuse it
                        // But also ensure temp entry has its own element created if needed
                        if (originalTc.executionTimeElement && originalTc.executionTimeElement.length > 0) {
                            // Store reference to original element, but we'll create a new one if needed
                            tempTc.originalExecutionTimeElement = originalTc.executionTimeElement;
                        }
                    }

                    return tempTc;
                }));

                if (subtree && subtree.fullName === testsWithoutPrefix[0] && testsWithoutPrefix.length === 1) {
                    // Single child - flatten
                    return groupTests[0];
                } else if (subtree) {
                    // Multiple children - create parent
                    const parent = new TestHtmlEntry(firstPrefix);
                    parent.setName(firstPrefix);
                    // Always add the subtree as a child (it could be a single node or a virtual root)
                    if (subtree.fullName === "Test Cases") {
                        // If it's a virtual root, add all its children directly
                        subtree.children.forEach(child => {
                            // Restore original full name if it exists (recursively)
                            restoreOriginalFullNames(child);
                            parent.addChild(child);
                        });
                    } else {
                        // If it's a single node, restore original full name and add it as a child (recursively)
                        restoreOriginalFullNames(subtree);
                        parent.addChild(subtree);
                    }
                    return parent;
                }
            }

            // Multiple different first-level prefixes - create virtual root
            const virtualRoot = new TestHtmlEntry("Test Cases");

            groups.forEach((groupTests, prefix) => {
                if (groupTests.length === 1) {
                    // Single test case in this group
                    const tc = groupTests[0];
                    tc.setName(tc.fullName);
                    virtualRoot.addChild(tc);
                } else {
                    // Multiple test cases - build subtree for this group
                    const subtree = buildCompactTree(groupTests);
                    if (subtree) {
                        virtualRoot.addChild(subtree);
                    }
                }
            });

            return virtualRoot;
        }

        function addToCompactTree(testEntry) {
            // During live updates, rebuild the entire tree from scratch each time
            // This ensures the tree is always correct and compact
            if (isListView) {
                // In list view, just rebuild the list
                rebuildCompactTree();
            } else if (!root) {
                // First test case
                testEntry.setName(testEntry.fullName);
                $('#test-cases-list').append(testEntry.listItem);
                root = testEntry;
            } else {
                // Get all existing test cases from the current tree
                const existingTestCases = getAllTestCasesFromTree(root);
                // Add the new test case
                existingTestCases.push(testEntry);

                // Rebuild the tree from all test cases
                $('#test-cases-list').empty();
                root = null;

                if (existingTestCases.length > 0) {
                    const treeRoot = buildCompactTree(existingTestCases);
                    if (treeRoot) {
                        $('#test-cases-list').append(treeRoot.listItem);
                        root = treeRoot;
                    }
                }
            }
        }

        function getAllTestCasesFromTree(node) {
            if (!node) return [];

            const result = [];
            if (node.traceHtmlFile) {
                // This is an actual test case (has traceHtmlFile)
                const newEntry = new TestHtmlEntry(node.fullName, node.traceHtmlFile, node.storageId || null);
                newEntry.Status = node.Status;
                result.push(newEntry);
            } else {
                // This is a parent node, continue traversing
                for (let child of node.children) {
                    result.push(...getAllTestCasesFromTree(child));
                }
            }

            return result;
        }

        // Legacy function - now just calls compact tree
        function addChildTestCase(testEntry, parentName) {
            // Always create parent nodes - we'll flatten them later if needed
            // This prevents the issue where test cases are flattened too early

            // Add a test case as a child of the specified parent
            let parentEntry = testMap.get(parentName);

            if (!parentEntry) {
                // Parent doesn't exist - create it
                parentEntry = new TestHtmlEntry(parentName);
                testMap.set(parentName, parentEntry);

                // Set display name for the parent (just the last part)
                const parentDisplayName = parentName.split('.').pop();
                parentEntry.setName(parentDisplayName);

                // Recursively add the parent to the tree
                const grandParentName = getParentName(parentName);

                if (grandParentName === "") {
                    addRootTestCase(parentEntry);
                } else {
                    // Check if grandparent already exists to avoid duplicate creation
                    if (!testMap.has(grandParentName)) {
                        addChildTestCase(parentEntry, grandParentName);
                    } else {
                        // Grandparent exists, just add parent to it
                        const grandParentEntry = testMap.get(grandParentName);
                        grandParentEntry.addChild(parentEntry);
                        grandParentEntry.updateChildStyling();
                    }
                }
            }

            // Set display name for the child (just the part after the parent)
            const displayName = testEntry.fullName.slice(parentName.length + 1);
            testEntry.setName(displayName);

            // Set display name for the parent (just the last part)
            const parentDisplayName = parentName.split('.').pop();
            parentEntry.setName(parentDisplayName);

            // Add child to parent
            parentEntry.addChild(testEntry);

            // Update styling after adding
            parentEntry.updateChildStyling();

            // Print tree structure for debugging (commented out for now)
            // printTreeStructure();

            // Don't automatically clean up - let test cases group under their parents
            // Cleanup will be called when the run finishes
        }

        function cleanupTreeStructure() {
            // Find all parent nodes that have only one child and flatten them
            const parentsToFlatten = [];

            testMap.forEach((entry, fullName) => {
                // Check if this is a parent node (no traceHtmlFile) with only one child
                if (!entry.traceHtmlFile && entry.children.length === 1) {
                    parentsToFlatten.push(entry);
                }
            });

            // Flatten single-child parents
            parentsToFlatten.forEach(parent => {
                const child = parent.children[0];

                // Update child's display name to include parent name
                child.setName(child.fullName);

                // Remove child from parent
                parent.removeChild(child);

                // If parent has a parent, add child to grandparent
                if (parent.parent) {
                    parent.parent.addChild(child);
                    // Remove the now-empty parent
                    parent.parent.removeChild(parent);
                    // Remove from testMap
                    testMap.delete(parent.fullName);
                } else {
                    // Parent is a root - replace it with child
                    if (root === parent) {
                        root = child;
                        $('#test-cases-list').empty();
                        $('#test-cases-list').append(child.listItem);
                    }
                    // Remove from testMap
                    testMap.delete(parent.fullName);
                }
            });
        }


        function rebuildTreeFromMap() {
            // Convert testMap to testData format and rebuild tree
            const testData = [];
            testMap.forEach((testEntry, fullName) => {
                // Only include actual test cases (those with URLs), not parent containers
                if (testEntry.traceHtmlFile) {
                    testData.push({
                        name: fullName,
                        status: testEntry.Status,
                        url: testEntry.traceHtmlFile
                    });
                }
            });

            if (testData.length > 0) {
                buildSmartTree(testData);
            }
        }


        // View toggle functionality
        function toggleView() {
            isListView = !isListView;
            const button = document.getElementById('view-toggle-btn');
            const listElement = document.getElementById('test-cases-list');
            const expandBtn = document.getElementById('expand-all-btn');
            const collapseBtn = document.getElementById('collapse-all-btn');

            if (isListView) {
                button.textContent = 'Tree View';
                listElement.className = 'list-view';
                // Hide expand/collapse buttons in list view
                expandBtn.style.display = 'none';
                collapseBtn.style.display = 'none';
                buildListView();
            } else {
                button.textContent = 'List View';
                listElement.className = 'tree';
                // Show expand/collapse buttons in tree view
                expandBtn.style.display = 'inline-block';
                collapseBtn.style.display = 'inline-block';
                rebuildCompactTree();
            }

            // Calculate and display execution time after view switch
            calculatePreloadedExecutionTimes();

            // Ensure classifications are applied after view switch
            if (classificationsData && Object.keys(classificationsData).length > 0) {
                requestAnimationFrame(() => {
                    applyClassificationsToTree();
                });
            }

            // Save user preference
            saveUserPreferences();
        }

        function buildListView() {
            const listElement = document.getElementById('test-cases-list');
            listElement.innerHTML = '';

            // Get filtered test cases from testMap and sort them
            const testCases = getFilteredTestEntries();
            const sortedTestCases = sortTestCases(testCases);

            if (sortedTestCases.length === 0) {
                renderEmptyState(listElement, 'No test cases match the selected filters.');
                return;
            }

            sortedTestCases.forEach(testCase => {
                const listItem = document.createElement('li');
                // Add data attribute for easy lookup by fullName
                listItem.setAttribute('data-tc-full-name', testCase.fullName);

                // Create main content container
                const contentContainer = document.createElement('div');
                contentContainer.style.display = 'flex';
                contentContainer.style.alignItems = 'center';
                contentContainer.style.justifyContent = 'space-between';
                contentContainer.style.width = '100%';

                // Create left side with link
                const leftSide = document.createElement('div');
                leftSide.className = 'list-left';
                leftSide.style.display = 'flex';
                leftSide.style.flexDirection = 'column';
                leftSide.style.flexGrow = '1';

                // Check if files exist on disk
                const filesExist = {{ files_exist | tojson }};

                // Create link or disabled span based on file existence
                let link;
                if (filesExist) {
                    link = document.createElement('a');
                    link.href = testCase.traceHtmlFile;
                    link.style.textDecoration = 'none';
                    link.style.color = '#007bff';
                } else {
                    link = document.createElement('span');
                    link.style.color = '#6c757d';
                    link.style.cursor = 'not-allowed';
                    link.title = 'Log files have been cleaned up due to retention policy';
                }

                // Create execution time element (for real-time updates)
                const timeElement = document.createElement('span');
                timeElement.className = 'execution-time';
                timeElement.style.fontSize = '0.85em';
                timeElement.style.color = '#6c757d';
                timeElement.style.marginLeft = '8px';
                timeElement.style.marginRight = '2px';

                // Set initial execution time if available
                if (testCase.executionTime) {
                    timeElement.textContent = `â±ï¸ ${testCase.executionTime}`;
                }

                // Create container for TC name + new TC indicator
                const textContainer = document.createElement('span');
                textContainer.className = 'list-left-text';
                textContainer.appendChild(document.createTextNode(testCase.fullName));

                // Add new TC indicator if applicable
                const classData = classificationsData[testCase.fullName];
                if (classData && classData.is_new && typeof Classifications !== 'undefined') {
                    const newIndicator = Classifications.createNewTcIndicator();
                    textContainer.appendChild(newIndicator);
                }

                link.appendChild(textContainer);

                leftSide.appendChild(link);
                contentContainer.appendChild(leftSide);

                // Create right side with badge + execution time + classification icon
                const rightSide = document.createElement('div');
                rightSide.className = 'list-view-right';
                rightSide.style.display = 'flex';
                rightSide.style.alignItems = 'center';
                rightSide.style.justifyContent = 'flex-start';
                rightSide.style.flexShrink = '0';

                // Store reference for real-time updates
                testCase.listViewExecutionTimeElement = timeElement;

                // Create badge
                if (testCase.badge) {
                    const badge = testCase.badge.clone();
                    const badgeEl = badge[0]; // Convert jQuery object to DOM element
                    rightSide.appendChild(badgeEl);

                    // Setup history hover on badge using async method
                    if (typeof Classifications !== 'undefined') {
                        const canonicalId = testCase.storageId || testCase.fullName;
                        Classifications.setupBadgeHistoryHoverAsync(badgeEl, canonicalId, runConfig.groupHash || null, runConfig.runId, testCase.fullName);
                    }
                }

                // Add execution time element after badge
                timeElement.style.marginLeft = '6px';
                rightSide.appendChild(timeElement);

                // Add classification icon if applicable
                if (classData && classData.classification && typeof Classifications !== 'undefined') {
                    const classIcon = Classifications.createClassificationIcon(classData.classification);
                    classIcon.style.marginLeft = '4px';
                    rightSide.appendChild(classIcon);
                }

                contentContainer.appendChild(rightSide);

                listItem.appendChild(contentContainer);
                listElement.appendChild(listItem);
            });

            // Re-establish execution time tracking for running tests
            reestablishExecutionTimeTracking();

            // Align status badges after list is fully rendered
            requestAnimationFrame(() => {
                alignStatusBadges();
            });
        }

        function sortTestCases(testCases) {
            switch (currentSortOrder) {
                case 'asc':
                    return testCases.sort((a, b) => a.fullName.localeCompare(b.fullName));
                case 'desc':
                    return testCases.sort((a, b) => b.fullName.localeCompare(a.fullName));
                case 'received':
                default:
                    // Sort by test case start time (order received)
                    return testCases.sort((a, b) => {
                        const timeA = a.startTime ? new Date(a.startTime).getTime() : 0;
                        const timeB = b.startTime ? new Date(b.startTime).getTime() : 0;
                        // If both have start times, sort by time
                        if (timeA && timeB) {
                            return timeA - timeB;
                        }
                        // If only one has a start time, it comes first
                        if (timeA && !timeB) return -1;
                        if (!timeA && timeB) return 1;
                        // Fallback to testCaseOrder for tests without start times
                        const indexA = testCaseOrder.indexOf(a.fullName);
                        const indexB = testCaseOrder.indexOf(b.fullName);
                        return indexA - indexB;
                    });
            }
        }

        function onSortChange() {
            const sortSelect = document.getElementById('sort-select');
            currentSortOrder = sortSelect.value;

            rebuildCurrentView();

            // Ensure classifications are applied after sort change
            if (classificationsData && Object.keys(classificationsData).length > 0) {
                requestAnimationFrame(() => {
                    applyClassificationsToTree();
                });
            }

            // Save user preference
            saveUserPreferences();
        }

        function onStatusFilterChange(filterKey, isChecked) {
            if (!STATUS_FILTER_KEYS.includes(filterKey)) return;
            if (statusFilters[filterKey] === isChecked) return;
            statusFilters[filterKey] = isChecked;
            saveUserPreferences();
            rebuildCurrentView();

            // Ensure classifications are applied after filter change
            if (classificationsData && Object.keys(classificationsData).length > 0) {
                requestAnimationFrame(() => {
                    applyClassificationsToTree();
                });
            }
        }

        // Expand/Collapse All functionality
        function expandAll() {
            expandCollapseTree(true);
        }

        function collapseAll() {
            expandCollapseTree(false);
        }

        function expandCollapseTree(expand) {
            if (!root) return;

            // Set the global state
            isCollapseAllActive = !expand;

            function traverse(entry) {
                if (entry.children && entry.children.length > 0) {
                    // This is a parent node with children
                    if (entry.indicator) {
                        if (expand) {
                            // Expand this node and all children
                            entry.expandNode(true);
                        } else {
                            // Collapse this node and all children
                            entry.collapseNode();
                        }
                    }

                    // Recursively traverse all children
                    entry.children.forEach(child => traverse(child));
                }
            }

            traverse(root);
        }

        // Initialize with existing test cases
        function initializeTestTree() {
            // Load user preferences first
            loadUserPreferences();

            // Apply preferences to UI elements
            applyUserPreferences();

            const testData = [
                {% for tc_full_name, tc_meta in test_cases.items() %}
                {
                    name: {{ tc_meta.tc_full_name|tojson }},
                    status: "{{ tc_meta.status }}",
                    url: LOG_URL_BASE + "{{ tc_meta.tc_id|urlencode }}.html",
                    storageId: {{ tc_meta.tc_id|tojson }},
                    start_time: "{{ tc_meta.start_time if tc_meta.start_time else '' }}",
                    end_time: "{{ tc_meta.end_time if tc_meta.end_time else '' }}"
                }{% if not loop.last %},{% endif %}
                {% endfor %}
            ];

            // Initialize test case order for existing test cases
            testData.forEach(test => {
                if (!testCaseOrder.includes(test.name)) {
                    testCaseOrder.push(test.name);
                }
            });

            // Check if any tests are running and add live indicator
            let hasRunningTests = false;
            testData.forEach(test => {
                if (test.status && test.status.toLowerCase() === 'running') {
                    hasRunningTests = true;
                }
            });

            // Also check if the overall run status is running
            const runStatus = "{{ status }}";
            if (runStatus && runStatus.toLowerCase() === 'running') {
                hasRunningTests = true;
            }

            if (hasRunningTests) {
                addLiveIndicator();
            }

            // Convert HTML entities to quotes in test case names
            testData.forEach(test => {
                test.name = test.name.replace(/&quot;/g, '"');
            });

            updateTree(testData);

            // Load classifications if in server mode with a group
            // Use setTimeout to ensure tree is fully built before applying classifications
            if (runConfig.serverMode && typeof Classifications !== 'undefined') {
                setTimeout(() => {
                    loadAndApplyClassifications();
                }, 100);
            }
        }

        // Load and apply test case classifications
        async function loadAndApplyClassifications() {
            try {
                const data = await Classifications.fetchClassifications(runConfig.runId);
                classificationsData = data;

                // Try to apply immediately
                applyClassificationsToTree();

                // Also retry after a short delay to ensure tree is fully rendered
                setTimeout(() => {
                    applyClassificationsToTree();
                }, 300);
            } catch (error) {
                console.error('Error loading classifications:', error);
            }
        }


        // Apply classifications to the test case tree or list view
        function applyClassificationsToTree() {
            if (!classificationsData) return;
            if (!testMap || testMap.size === 0) return; // Tree not built yet

            if (isListView) {
                // For list view, find elements in DOM and apply classifications
                const listElement = document.getElementById('test-cases-list');
                if (!listElement) return;

                testMap.forEach((testEntry, fullName) => {
                    if (!testEntry.traceHtmlFile) return; // Skip parent containers

                    const classData = classificationsData[fullName];
                    if (!classData) return;

                    // Find the list item for this test case using data attribute
                    const targetListItem = listElement.querySelector(`li[data-tc-full-name="${CSS.escape(fullName)}"]`);

                    if (!targetListItem) return;

                    // Find the right side container (where badge and classification icon go)
                    const contentContainer = targetListItem.querySelector('div[style*="display: flex"]');
                    if (!contentContainer) return;

                    const rightSide = contentContainer.querySelector('div:last-child');
                    if (!rightSide) return;

                    // Add classification icon if applicable (check if not already added)
                    if (classData.classification && typeof Classifications !== 'undefined') {
                        if (!rightSide.querySelector('.classification-icon')) {
                            const classIcon = Classifications.createClassificationIcon(classData.classification);
                            rightSide.appendChild(classIcon);
                        }
                    }

                    // Add new TC indicator if applicable (check if not already added)
                    if (classData.is_new && typeof Classifications !== 'undefined') {
                        const link = targetListItem.querySelector('a');
                        if (link) {
                            const textContainer = link.querySelector('span');
                            if (textContainer && !textContainer.querySelector('.new-tc-indicator')) {
                                const newIndicator = Classifications.createNewTcIndicator();
                                // Insert after the test case name text node
                                const textNode = Array.from(textContainer.childNodes).find(n => n.nodeType === 3);
                                if (textNode && textNode.nextSibling) {
                                    textContainer.insertBefore(newIndicator, textNode.nextSibling);
                                } else {
                                    textContainer.appendChild(newIndicator);
                                }
                            }
                        }
                    }
                });
            } else {
                // For tree view, find elements in DOM by data attribute (like list view)
                // This ensures we're working with the actual DOM elements after tree rebuild
                const treeElement = document.getElementById('test-cases-list');
                if (!treeElement) return;

                testMap.forEach((testEntry, fullName) => {
                    if (!testEntry.traceHtmlFile) return; // Skip parent containers

                    const classData = classificationsData[fullName];
                    if (!classData) return;

                    // Find the tree node for this test case using data attribute
                    const targetNode = treeElement.querySelector(`li[data-tc-full-name="${CSS.escape(fullName)}"]`);
                    if (!targetNode) return;

                    // Find classification container in the DOM
                    const classificationContainer = targetNode.querySelector('.classification-container');
                    if (classData.classification && classificationContainer) {
                        if (!classificationContainer.querySelector('.classification-icon')) {
                            const icon = Classifications.createClassificationIcon(classData.classification);
                            classificationContainer.appendChild(icon);
                        }
                    }

                    // Find new TC indicator container in the DOM
                    const newTcContainer = targetNode.querySelector('.new-tc-container');
                    if (classData.is_new && newTcContainer) {
                        if (!newTcContainer.querySelector('.new-tc-indicator')) {
                            const indicator = Classifications.createNewTcIndicator();
                            newTcContainer.appendChild(indicator);
                        }
                    }
                });
            }

            // Also setup hover on run status badge if we have a group
            if (runConfig.groupHash) {
                const runStatusBadge = document.querySelector('.status-badge-top .status-badge');
                if (runStatusBadge && !runStatusBadge.classList.contains('status-badge-with-history')) {
                    Classifications.setupRunBadgeHistoryHover(runStatusBadge, runConfig.groupHash, runConfig.runId);
                }
            }

            // Update collapsed classification icons for any nodes that are already collapsed
            updateAllCollapsedClassifications();
        }

        // Update collapsed classification icons for all collapsed parent nodes
        function updateAllCollapsedClassifications() {
            if (!root || !classificationsData) return;

            function updateCollapsedNodes(node) {
                if (node.children && node.children.length > 0) {
                    // This is a parent node
                    if (node.isCollapsed && node.collapsedClassificationContainer) {
                        node.updateCollapsedClassifications();
                    }
                    // Recurse into children
                    node.children.forEach(child => updateCollapsedNodes(child));
                }
            }

            updateCollapsedNodes(root);
        }

        // Function to convert UTC time to local time
        function convertToLocalTime(utcTimeString) {
            if (!utcTimeString) return utcTimeString;
            try {
                const utcDate = new Date(utcTimeString);
                const localTime = utcDate.toLocaleString();
                return localTime;
            } catch (e) {
                console.warn('Failed to parse time:', utcTimeString, e);
                return utcTimeString;
            }
        }

        // Function to convert all time elements to local time
        function convertTimesToLocal() {
            // Convert start time display
            const startTimeDisplay = document.getElementById('start-time-display');
            if (startTimeDisplay && startTimeDisplay.textContent) {
                const text = startTimeDisplay.textContent.trim();
                if (text && text !== 'Not finished' && (text.includes('T') || text.includes('Z') || text.includes('-'))) {
                    const localTime = convertToLocalTime(text);
                    startTimeDisplay.textContent = localTime;
                }
            }

            // Convert end time display
            const endTimeDisplay = document.getElementById('end-time-display');
            if (endTimeDisplay && endTimeDisplay.textContent) {
                const text = endTimeDisplay.textContent.trim();
                if (text && text !== 'Not finished' && (text.includes('T') || text.includes('Z') || text.includes('-'))) {
                    const localTime = convertToLocalTime(text);
                    endTimeDisplay.textContent = localTime;
                }
            }

            // Re-establish execution time tracking for any running tests
            reestablishExecutionTimeTracking();
        }

        function showDownloadButton() {
            const downloadSection = document.querySelector('.download-section');
            const filesExist = {{ files_exist | tojson }};

            if (downloadSection && !downloadSection.querySelector('.download-btn')) {
                if (filesExist) {
                    const downloadBtn = document.createElement('a');
                    downloadBtn.href = '/export/{{ run_id }}.zip';
                    downloadBtn.className = 'download-btn';
                    downloadBtn.textContent = 'ðŸ“¥ Download ZIP';
                    downloadSection.appendChild(downloadBtn);
                } else {
                    const downloadBtn = document.createElement('span');
                    downloadBtn.className = 'download-btn disabled';
                    downloadBtn.title = 'Files have been cleaned up due to retention policy';
                    downloadBtn.textContent = 'ðŸ“¥ Download ZIP';
                    downloadSection.appendChild(downloadBtn);
                }
            }
        }

        // =====================
        // Metrics Chart Rendering
        // =====================
        let metricsChartCtx = null;

        function initializeMetricsChart() {
            const canvas = document.getElementById('metrics-chart');
            if (!canvas) return;
            metricsChartCtx = canvas.getContext('2d');

            // Initial render if we have data
            if (metricsData && metricsData.length > 0) {
                renderMetricsChart();
            }
        }

        function renderMetricsChart() {
            if (!metricsData || metricsData.length === 0) {
                document.getElementById('metrics-section').style.display = 'none';
                return;
            }

            // Ensure context is initialized
            if (!metricsChartCtx) {
                const canvas = document.getElementById('metrics-chart');
                if (!canvas) return;
                metricsChartCtx = canvas.getContext('2d');
            }

            document.getElementById('metrics-section').style.display = 'block';

            const canvas = document.getElementById('metrics-chart');
            const ctx = metricsChartCtx;
            // Use container width or fallback to a reasonable default
            let width = canvas.offsetWidth;
            if (width === 0) {
                // Section was just shown, get parent width or use default
                const container = canvas.closest('.metrics-chart-container');
                width = container ? container.offsetWidth : 800;
                if (width === 0) width = 800;
            }
            const height = 80;

            // Set actual canvas size (accounting for device pixel ratio for sharpness)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Calculate statistics
            const cpuValues = metricsData.map(m => m.cpu || 0);
            const memValues = metricsData.map(m => m.mem || 0);
            const netValues = metricsData.map(m => m.net || 0);

            const cpuMin = Math.min(...cpuValues);
            const cpuMax = Math.max(...cpuValues);
            const cpuAvg = cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length;

            const memMin = Math.min(...memValues);
            const memMax = Math.max(...memValues);
            const memAvg = memValues.reduce((a, b) => a + b, 0) / memValues.length;

            const netMin = Math.min(...netValues);
            const netMax = Math.max(...netValues);
            const netAvg = netValues.reduce((a, b) => a + b, 0) / netValues.length;

            // Update summary stats
            document.getElementById('cpu-min').textContent = cpuMin.toFixed(1) + '%';
            document.getElementById('cpu-avg').textContent = cpuAvg.toFixed(1) + '%';
            document.getElementById('cpu-max').textContent = cpuMax.toFixed(1) + '%';
            document.getElementById('mem-min').textContent = memMin.toFixed(1) + '%';
            document.getElementById('mem-avg').textContent = memAvg.toFixed(1) + '%';
            document.getElementById('mem-max').textContent = memMax.toFixed(1) + '%';
            document.getElementById('net-min').textContent = netMin.toFixed(1) + '%';
            document.getElementById('net-avg').textContent = netAvg.toFixed(1) + '%';
            document.getElementById('net-max').textContent = netMax.toFixed(1) + '%';

            // Chart drawing parameters
            const padding = { top: 5, right: 10, bottom: 5, left: 10 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Y axis: 0-100%
            const yScale = (v) => padding.top + chartHeight - (v / 100) * chartHeight;
            const xScale = (i) => padding.left + (i / (metricsData.length - 1 || 1)) * chartWidth;

            // Draw background grid lines
            ctx.strokeStyle = '#c5ccd4';
            ctx.lineWidth = 1;
            for (let p = 0; p <= 100; p += 25) {
                const y = yScale(p);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }

            // Draw System CPU line
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            metricsData.forEach((m, i) => {
                const x = xScale(i);
                const y = yScale(m.cpu || 0);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw Memory line
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2;
            ctx.beginPath();
            metricsData.forEach((m, i) => {
                const x = xScale(i);
                const y = yScale(m.mem || 0);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw Network line
            ctx.strokeStyle = '#e67e22';
            ctx.lineWidth = 2;
            ctx.beginPath();
            metricsData.forEach((m, i) => {
                const x = xScale(i);
                const y = yScale(m.net || 0);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function handleMetricsUpdate(metrics) {
            if (!metrics || !Array.isArray(metrics)) return;

            // Append new metrics
            metrics.forEach(m => {
                metricsData.push({
                    ts: m.ts || m.timestamp,
                    cpu: m.cpu || 0,
                    mem: m.mem || m.memory || 0,
                    net: m.net || 0,
                    ni: m.ni || null
                });
            });

            // Downsample if too many samples (keep max ~2000 for chart rendering)
            const maxSamples = 2000;
            while (metricsData.length > maxSamples) {
                metricsData = downsampleMetrics(metricsData);
            }

            // Re-render chart
            renderMetricsChart();
        }

        function downsampleMetrics(data) {
            // Average consecutive pairs to halve the sample count
            const result = [];
            for (let i = 0; i < data.length - 1; i += 2) {
                const m1 = data[i];
                const m2 = data[i + 1];
                result.push({
                    ts: Math.round((m1.ts + m2.ts) / 2),
                    cpu: Math.round(((m1.cpu + m2.cpu) / 2) * 10) / 10,
                    mem: Math.round(((m1.mem + m2.mem) / 2) * 10) / 10,
                    net: Math.round(((m1.net + m2.net) / 2) * 10) / 10,
                    ni: m1.ni || m2.ni  // Keep interface details from either sample
                });
            }
            // Handle odd count - keep last sample
            if (data.length % 2 === 1) {
                result.push(data[data.length - 1]);
            }
            return result;
        }

        // Metrics chart hover tooltip for showing running test cases
        let metricsTooltipPinned = false;
        let lastTooltipSampleIndex = -1;

        function initializeMetricsChartHover() {
            const canvas = document.getElementById('metrics-chart');
            const tooltip = document.getElementById('metrics-tooltip');
            if (!canvas || !tooltip) return;

            const padding = { top: 5, right: 10, bottom: 5, left: 10 };
            const filesExist = {{ files_exist | tojson if files_exist is defined else 'true' }};

            function updateTooltip(e) {
                if (!metricsData || metricsData.length === 0) {
                    if (!metricsTooltipPinned) tooltip.style.display = 'none';
                    return;
                }

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const chartWidth = rect.width - padding.left - padding.right;

                // Determine which sample index we're hovering over
                const ratio = (x - padding.left) / chartWidth;
                const sampleIndex = Math.round(ratio * (metricsData.length - 1));
                if (sampleIndex < 0 || sampleIndex >= metricsData.length) {
                    if (!metricsTooltipPinned) tooltip.style.display = 'none';
                    return;
                }

                lastTooltipSampleIndex = sampleIndex;
                renderTooltipContent(sampleIndex, e, rect, filesExist);
            }

            function renderTooltipContent(sampleIndex, e, rect, filesExist) {
                const sample = metricsData[sampleIndex];
                const sampleTs = sample.ts;

                // Find test cases running at this timestamp
                const runningTests = [];
                testMap.forEach((testEntry, testId) => {
                    if (!testEntry.startTime) return;
                    const testStart = new Date(testEntry.startTime).getTime();
                    let testEnd = testEntry.endTime ? new Date(testEntry.endTime).getTime() : Date.now();
                    // If still running, use current time
                    if (testEntry.Status && testEntry.Status.toLowerCase() === 'running') {
                        testEnd = Date.now();
                    }
                    if (sampleTs >= testStart && sampleTs <= testEnd) {
                        runningTests.push({ name: testEntry.name || testId, url: testEntry.traceHtmlFile });
                    }
                });

                // Build tooltip content
                const time = new Date(sampleTs).toLocaleTimeString();
                let html = `<div style="margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">`;
                html += `<strong>${time}</strong>`;
                if (metricsTooltipPinned) {
                    html += `<span id="close-metrics-tooltip" style="cursor: pointer; margin-left: 15px; color: #888; font-size: 14px;">&times;</span>`;
                } else {
                    html += `<span style="font-size: 10px; color: #888; margin-left: 10px;">click to pin</span>`;
                }
                html += `</div>`;
                html += `<div>CPU: <span style="color: #a3b3f4">${(sample.cpu || 0).toFixed(1)}%</span></div>`;
                html += `<div>Memory: <span style="color: #68d391">${(sample.mem || 0).toFixed(1)}%</span></div>`;
                html += `<div>Network: <span style="color: #f5a860">${(sample.net || 0).toFixed(1)}%</span>`;
                // Show per-interface details if available
                if (sample.ni && sample.ni.length > 0) {
                    html += ` <span style="color: #888; font-size: 11px;">(`;
                    html += sample.ni.map(iface => `${iface.n}: â†‘${(iface.tx || 0).toFixed(1)}% â†“${(iface.rx || 0).toFixed(1)}%`).join(', ');
                    html += `)</span>`;
                }
                html += `</div>`;

                if (runningTests.length > 0) {
                    html += `<div style="margin-top: 8px; border-top: 1px solid #555; padding-top: 6px;">`;
                    html += `<strong>Running (${runningTests.length}):</strong>`;
                    const displayTests = runningTests.slice(0, 10);
                    displayTests.forEach(tc => {
                        const shortName = tc.name.length > 60 ? '...' + tc.name.slice(-57) : tc.name;
                        if (filesExist && tc.url && metricsTooltipPinned) {
                            // Clickable link when pinned and files exist
                            html += `<div style="font-size: 11px; margin: 2px 0;"><a href="${tc.url}" style="color: #7dd3fc; text-decoration: none;" target="_blank">${shortName}</a></div>`;
                        } else {
                            html += `<div style="font-size: 11px; color: #ccc; margin: 2px 0;">${shortName}</div>`;
                        }
                    });
                    if (runningTests.length > 10) {
                        html += `<div style="font-size: 11px; color: #888;">...and ${runningTests.length - 10} more</div>`;
                    }
                    html += `</div>`;
                }

                tooltip.innerHTML = html;
                tooltip.style.display = 'block';

                // Add close button handler if pinned
                if (metricsTooltipPinned) {
                    const closeBtn = document.getElementById('close-metrics-tooltip');
                    if (closeBtn) {
                        closeBtn.addEventListener('click', function(ev) {
                            ev.stopPropagation();
                            metricsTooltipPinned = false;
                            tooltip.style.display = 'none';
                        });
                    }
                }

                // Position tooltip (only when not pinned or on initial pin)
                if (!metricsTooltipPinned || !tooltip.dataset.positioned) {
                    const containerRect = canvas.closest('.metrics-chart-container').getBoundingClientRect();
                    // First, show tooltip to measure its size
                    tooltip.style.visibility = 'hidden';
                    tooltip.style.display = 'block';
                    const tooltipWidth = tooltip.offsetWidth;
                    tooltip.style.visibility = 'visible';

                    let tooltipX = e.clientX - containerRect.left + 15;
                    let tooltipY = 5;

                    // If tooltip would go off right edge, position it to the left of cursor
                    if (tooltipX + tooltipWidth > containerRect.width - 10) {
                        tooltipX = e.clientX - containerRect.left - tooltipWidth - 15;
                    }
                    // Ensure it doesn't go off left edge
                    if (tooltipX < 5) tooltipX = 5;

                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                    if (metricsTooltipPinned) tooltip.dataset.positioned = 'true';
                }
            }

            canvas.addEventListener('mousemove', function(e) {
                if (!metricsTooltipPinned) {
                    updateTooltip(e);
                }
            });

            canvas.addEventListener('click', function(e) {
                if (metricsTooltipPinned) {
                    // Unpin
                    metricsTooltipPinned = false;
                    tooltip.dataset.positioned = '';
                    updateTooltip(e);
                } else {
                    // Pin at current position
                    metricsTooltipPinned = true;
                    const rect = canvas.getBoundingClientRect();
                    const filesExist = {{ files_exist | tojson if files_exist is defined else 'true' }};
                    renderTooltipContent(lastTooltipSampleIndex, e, rect, filesExist);
                }
            });

            canvas.addEventListener('mouseleave', function() {
                if (!metricsTooltipPinned) {
                    tooltip.style.display = 'none';
                }
            });

            // Close tooltip when clicking outside
            document.addEventListener('click', function(e) {
                if (metricsTooltipPinned && !tooltip.contains(e.target) && e.target !== canvas) {
                    metricsTooltipPinned = false;
                    tooltip.dataset.positioned = '';
                    tooltip.style.display = 'none';
                }
            });
        }

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                if (metricsData && metricsData.length > 0) {
                    renderMetricsChart();
                }
            }, 100);
        });

        $(document).ready(function () {
            convertTimesToLocal(); // Convert times on page load
            initializeTestTree();
            initializeRunExecutionTime();
            initializeMetricsChart();
            initializeMetricsChartHover();

            // Add event listeners for expand/collapse buttons
            $('#expand-all-btn').on('click', function() {
                expandAll();
            });

            $('#collapse-all-btn').on('click', function() {
                collapseAll();
            });

            $('#view-toggle-btn').on('click', function() {
                toggleView();
            });

            $('#sort-select').on('change', function() {
                onSortChange();
            });

            STATUS_FILTER_KEYS.forEach(key => {
                const checkbox = document.getElementById(`filter-${key}`);
                if (checkbox) {
                    checkbox.addEventListener('change', (event) => {
                        onStatusFilterChange(key, event.target.checked);
                    });
                }
            });

            {% if live_run %}
            const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
            const ws = new WebSocket(`${scheme}://${location.host}/ws/ui`);
            ws.binaryType = 'arraybuffer';

            // UI Update Throttling - batch WebSocket updates and apply every 500ms
            let pendingUpdates = {
                testCaseStarted: [],
                testCaseFinished: [],
                metrics: [],
                runFinished: null
            };
            let uiUpdateScheduled = false;
            const UI_UPDATE_INTERVAL = 500; // ms

            function scheduleUIUpdate() {
                if (uiUpdateScheduled) return;
                uiUpdateScheduled = true;
                setTimeout(flushUIUpdates, UI_UPDATE_INTERVAL);
            }

            function flushUIUpdates() {
                uiUpdateScheduled = false;

                // Process test case started
                pendingUpdates.testCaseStarted.forEach(msg => {
                    addOrUpdateTestCase(msg.test_case_full_name, msg.tc_meta, true);
                });
                if (pendingUpdates.testCaseStarted.length > 0) {
                    addLiveIndicator();
                }
                pendingUpdates.testCaseStarted = [];

                // Process test case finished
                pendingUpdates.testCaseFinished.forEach(msg => {
                    addOrUpdateTestCase(msg.test_case_full_name, msg.tc_meta);
                    if (msg.counts) {
                        updateResultBadges(msg.counts);
                    }
                });
                pendingUpdates.testCaseFinished = [];

                // Check if any tests are still running
                let hasRunningTests = false;
                testMap.forEach((testEntry) => {
                    if (testEntry.Status && testEntry.Status.toLowerCase() === 'running') {
                        hasRunningTests = true;
                    }
                });
                if (!hasRunningTests) {
                    removeLiveIndicator();
                }

                // Process metrics updates (batch all pending metrics together)
                if (pendingUpdates.metrics.length > 0) {
                    const allMetrics = pendingUpdates.metrics.flat();
                    if (allMetrics.length > 0) {
                        handleMetricsUpdate(allMetrics);
                    }
                    pendingUpdates.metrics = [];
                }

                // Process run finished (use latest)
                if (pendingUpdates.runFinished) {
                    processRunFinished(pendingUpdates.runFinished);
                    pendingUpdates.runFinished = null;
                }
            }

            ws.onmessage = (event) => {
                try {
                    const msg = msgpack.decode(new Uint8Array(event.data));
                    if (msg.type === 'test_case_started' && msg.run_id === '{{ run_id }}') {
                        pendingUpdates.testCaseStarted.push(msg);
                        scheduleUIUpdate();
                    }
                    else if (msg.type === 'metrics' && msg.run_id === '{{ run_id }}') {
                        pendingUpdates.metrics.push(msg.metrics);
                        scheduleUIUpdate();
                    }
                    else if ((msg.type === 'test_case_finished' || msg.type === 'test_case_updated') && msg.run_id === '{{ run_id }}') {
                        pendingUpdates.testCaseFinished.push(msg);
                        scheduleUIUpdate();
                    }
                    else if ((msg.type === 'run_finished' || msg.type === 'run_updated') && msg.run.run_id === '{{ run_id }}') {
                        pendingUpdates.runFinished = msg;
                        scheduleUIUpdate();
                    }
                } catch(e) {
                    console.error('Failed to decode message:', e);
                }
            };

            function processRunFinished(msg) {
                // Add live indicator if run status is running
                if (msg.run.status && msg.run.status.toLowerCase() === 'running') {
                    addLiveIndicator();
                    // Start run execution time tracking if not already started
                    if (!runStartTime && msg.run.start_time) {
                        // Find the earliest test case start time for more accurate execution time
                        let earliestStartTime = null;
                        let earliestStartTimeStr = '';

                        testMap.forEach((testEntry, testId) => {
                            if (testEntry.startTime) {
                                // Test case start times are local time strings - convert to UTC milliseconds for comparison
                                const testStartTime = new Date(testEntry.startTime).getTime();
                                if (!earliestStartTime || testStartTime < earliestStartTime) {
                                    earliestStartTime = testStartTime;
                                    earliestStartTimeStr = testEntry.startTime;
                                }
                            }
                        });

                        // Use earliest test case start time if available, otherwise use run start time
                        const startTimeToUse = earliestStartTimeStr || msg.run.start_time;
                        runStartTime = new Date(startTimeToUse).getTime();
                        showRunExecutionTime();
                        startRunExecutionTimer();
                    }
                } else {
                    // Run finished - stop real-time tracking and show final time
                    stopRunExecutionTimer();
                    if (msg.run.start_time && msg.run.end_time) {
                        // Calculate and show final execution time
                        let startTimeStr = msg.run.start_time;
                        let endTimeStr = msg.run.end_time;

                        if (!endTimeStr.includes('Z') && !endTimeStr.includes('+') && !endTimeStr.includes('-', 10)) {
                            endTimeStr += 'Z';
                        }

                        const start = new Date(startTimeStr);
                        const end = new Date(endTimeStr);
                        const duration = end - start;

                        if (duration > 0) {
                            const formattedTime = formatExecutionTime(duration);
                            const runExecutionTimeElement = document.getElementById('run-execution-time');
                            if (runExecutionTimeElement) {
                                runExecutionTimeElement.textContent = `â±ï¸ ${formattedTime}`;
                                runExecutionTimeElement.style.display = 'inline';
                            }
                        }
                    }
                }

                // Show download button when run finishes
                showDownloadButton();

                // Update result badges and status badge using new functions
                // Count test results for badges
                let passedCount = 0;
                let failedCount = 0;
                let skippedCount = 0;
                let abortedCount = 0;
                let errorCount = 0;

                testMap.forEach((testEntry) => {
                    // Only count test cases that have URLs (actual test cases, not parent containers)
                    if (testEntry.traceHtmlFile && testEntry.Status) {
                        const status = testEntry.Status.toLowerCase();
                        if (status === 'passed') {
                            passedCount++;
                        } else if (status === 'failed') {
                            failedCount++;
                        } else if (status === 'skipped') {
                            skippedCount++;
                        } else if (status === 'error') {
                            errorCount++;
                        } else if (status === 'aborted') {
                            abortedCount++;
                        }
                    }
                });

                // Update result badges
                updateResultBadges({passed: passedCount, failed: failedCount, skipped: skippedCount, aborted: abortedCount, error: errorCount});

                // Update top-right status badge
                updateTopStatusBadge(msg.run, {passed: passedCount, failed: failedCount, skipped: skippedCount, aborted: abortedCount, error: errorCount});

                // Update End Time if available
                if (msg.run.end_time) {
                    const endTimeDisplay = document.getElementById('end-time-display');
                    if (endTimeDisplay) {
                        endTimeDisplay.textContent = convertToLocalTime(msg.run.end_time);
                    }
                }

                // Remove live indicator when run finishes
                if (msg.run.status.toLowerCase() === 'finished') {
                    removeLiveIndicator();
                    // Rebuild the tree with compact structure when run finishes
                    rebuildCompactTree();
                }
            }
            {% endif %}
        });

        // Helper functions for updating result badges and status
        function updateResultBadges(counts) {
            const runStatusContainer = document.getElementById('run-status-container');
            if (!runStatusContainer) return;

            // Clear existing badges
            runStatusContainer.innerHTML = '';

            // Create new badges based on counts
            if (counts.passed > 0) {
                const passedBadge = document.createElement('span');
                passedBadge.className = 'result-badge result-passed';
                passedBadge.textContent = `PASSED: ${counts.passed}`;
                runStatusContainer.appendChild(passedBadge);
            }

            if (counts.skipped > 0) {
                const skippedBadge = document.createElement('span');
                skippedBadge.className = 'result-badge result-skipped';
                skippedBadge.textContent = `SKIPPED: ${counts.skipped}`;
                runStatusContainer.appendChild(skippedBadge);
            }

            if (counts.failed > 0) {
                const failedBadge = document.createElement('span');
                failedBadge.className = 'result-badge result-failed';
                failedBadge.textContent = `FAILED: ${counts.failed}`;
                runStatusContainer.appendChild(failedBadge);
            }

            // Combine error and aborted counts into a single ERROR badge
            const combinedErrorCount = (counts.error || 0) + (counts.aborted || 0);
            if (combinedErrorCount > 0) {
                const errorBadge = document.createElement('span');
                errorBadge.className = 'result-badge result-error';
                errorBadge.textContent = `ERROR: ${combinedErrorCount}`;
                runStatusContainer.appendChild(errorBadge);
            }
        }

        function updateTopStatusBadge(run, counts) {
            const statusBadgeTop = document.querySelector('.status-badge-top');
            if (!statusBadgeTop) return;

            // Clear existing badge
            statusBadgeTop.innerHTML = '';

            // Only use the run status to determine the badge, not individual test case statuses
            if (run && run.status) {
                const runStatus = run.status.toLowerCase();

                if (runStatus === 'running') {
                    // Show running badge with spinner
                    const runningBadge = document.createElement('span');
                    runningBadge.className = 'status-badge status-running';
                    runningBadge.textContent = 'RUNNING ';
                    const spinner = document.createElement('span');
                    spinner.className = 'spinner';
                    runningBadge.appendChild(spinner);
                    statusBadgeTop.appendChild(runningBadge);
                } else if (runStatus === 'aborted') {
                    // Show aborted badge with abort reason tooltip if available
                    const abortedBadge = document.createElement('span');
                    abortedBadge.className = 'status-badge status-aborted';
                    abortedBadge.textContent = 'ABORTED';
                    if (run.abort_reason) {
                        abortedBadge.title = run.abort_reason;
                    }
                    statusBadgeTop.appendChild(abortedBadge);
                } else if (runStatus === 'finished') {
                    // Show finished badge - use counts if available, otherwise calculate from testMap
                    let passedCount = 0;
                    let failedCount = 0;
                    let skippedCount = 0;
                    let abortedCount = 0;
                    let errorCount = 0;
                    if (counts) {
                        passedCount = counts.passed || 0;
                        failedCount = counts.failed || 0;
                        skippedCount = counts.skipped || 0;
                        abortedCount = counts.aborted || 0;
                        errorCount = counts.error || 0;
                    } else if (run && run.test_cases) {
                        // Fallback: calculate from run data
                        for (const tcId in run.test_cases) {
                            const tc = run.test_cases[tcId];
                            const s = tc.status ? tc.status.toLowerCase() : '';
                            if (s === 'passed') {
                                passedCount++;
                            } else if (s === 'failed') {
                                failedCount++;
                            } else if (s === 'skipped') {
                                skippedCount++;
                            } else if (s === 'error') {
                                errorCount++;
                            } else if (s === 'aborted') {
                                abortedCount++;
                            }
                        }
                    } else {
                        // Fallback: calculate from testMap
                        testMap.forEach((testEntry) => {
                            if (testEntry.Status) {
                                const status = testEntry.Status.toLowerCase();
                                if (status === 'passed') {
                                    passedCount++;
                                } else if (status === 'failed') {
                                    failedCount++;
                                } else if (status === 'skipped') {
                                    skippedCount++;
                                } else if (status === 'error') {
                                    errorCount++;
                                } else if (status === 'aborted') {
                                    abortedCount++;
                                }
                            }
                        });
                    }

                    const finishedBadge = document.createElement('span');
                    // Priority: Error > Failed/Aborted > Skipped (all) > Passed
                    if (skippedCount > 0 && passedCount === 0 && failedCount === 0 && abortedCount === 0 && errorCount === 0) {
                        finishedBadge.className = 'status-badge status-skipped';
                        finishedBadge.textContent = 'SKIPPED';
                    } else if (errorCount > 0) {
                        finishedBadge.className = 'status-badge status-error';
                        finishedBadge.textContent = 'ERROR';
                    } else if (failedCount > 0 || abortedCount > 0) {
                        finishedBadge.className = 'status-badge status-finished-failed';
                        finishedBadge.textContent = 'FAILED';
                    } else {
                        finishedBadge.className = 'status-badge status-finished-passed';
                        finishedBadge.textContent = 'PASSED';
                    }
                    statusBadgeTop.appendChild(finishedBadge);
                }
            }
        }
    </script>
</body>
</html>